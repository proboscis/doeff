from collections.abc import Callable, Generator
from typing import Any, Generic, TypeVar

from doeff.utils import BoundedLog

__VENDORED_EXPORTS: Any
T = TypeVar("T")
U = TypeVar("U")

# Repr truncation configuration
DEFAULT_REPR_LIMIT: int
REPR_LIMIT_KEY: str

def _truncate_repr(obj: object, limit: int | None) -> str: ...
_TRACEBACK_ATTR: Any
EffectFailure: Any
E: Any
ProgramGenerator: Any
FailureEntry: Any
__all__: Any

def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]: ...

def _split_traceback_header(lines: list[str]) -> tuple[list[str], list[str]]: ...

def _choose_head_tail_lengths(body: list[str], available_frames: int) -> tuple[int, int]: ...

def _initial_tail_length(available_frames: int) -> int: ...

def _rebalance_for_user_frames(body: list[str], head_lines: int, tail_lines: int, desired_user_frames: int = ..., tail_min: int = ...) -> tuple[int, int]: ...

def _grow_head_with_tail(head_lines: int, tail_lines: int, extra_needed: int, tail_min: int) -> tuple[int, int]: ...

def _find_user_span_end(body: list[str], desired: int) -> int | None: ...

def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]: ...

def _extract_traceback_path(line: str) -> str | None: ...

def _is_library_traceback_path(path: str) -> bool: ...

def capture_traceback(exc: BaseException) -> CapturedTraceback: ...

def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None: ...

def _intercept_value(value: Any, transform: Callable[Any, Effect | Program]) -> Any: ...

def _intercept_mapping(mapping: dict[Any, Any], transform: Callable[Any, Effect | Program]) -> dict[Any, Any]: ...

def _intercept_tuple(items: tuple[Any, Any], transform: Callable[Any, Effect | Program]) -> tuple[Any, Any]: ...

def _wrap_callable(func: Callable[Any, Any], transform: Callable[Any, Effect | Program]) -> Any: ...

class EffectObservation:
    effect_type: str
    key: str | None
    context: EffectCreationContext | None

class _DepAskStats:
    records: tuple[_DepAskUsageRecord, Any]
    keys_by_type: dict[str, tuple[str | None, Any]]
    def from_observations(cls, observations: list[EffectObservation]) -> _DepAskStats: ...
    def is_empty(self) -> bool: ...
    def keys_for(self, effect_type: str) -> tuple[str | None, Any]: ...

class RunResultDisplayContext:
    run_result: RunResult[Any]
    verbose: bool
    indent_unit: str
    failure_details: RunFailureDetails | None
    dep_ask_stats: _DepAskStats
    def indent(self, level: int, text: str) -> str: ...

class _StatusSection:
    def render(self) -> list[str]: ...

class _SharedStateSection:
    def render(self) -> list[str]: ...

class RunResultDisplayRenderer:
    context: RunResultDisplayContext
    def render(self) -> str: ...

class EffectFailureError:
    effect: Effect
    cause: BaseException
    runtime_traceback: CapturedTraceback | None
    creation_context: EffectCreationContext | None
    def __str__(self) -> str: ...
    def __post_init__(self) -> Any: ...

class ListenResult:
    value: Any
    log: BoundedLog
    def __iter__(self) -> Any: ...

class _BaseSection:
    context: RunResultDisplayContext
    def indent(self, level: int, text: str) -> str: ...
    def format_value(self, value: Any, max_length: int = ...) -> str: ...

class _HeaderSection:
    def render(self) -> list[str]: ...

class CapturedTraceback:
    traceback: traceback.TracebackException
    def _raw_lines(self) -> list[str]: ...
    def _sanitize_lines(self) -> list[str]: ...
    def lines(self, condensed: bool = ..., max_lines: int = ...) -> list[str]: ...
    def format(self, condensed: bool = ..., max_lines: int = ...) -> str: ...

class _GraphSection:
    def render(self) -> list[str]: ...

class Effect:
    created_at: EffectCreationContext | None
    def intercept(self, transform: Callable[Any, Effect | Program]) -> Effect: ...
    def with_created_at(self: E, created_at: EffectCreationContext | None) -> E: ...

class ExceptionFailureInfo:
    exception: BaseException
    trace: CapturedTraceback | None

class _EffectKeysSection:
    def render(self) -> list[str]: ...

class _StateSection:
    def render(self) -> list[str]: ...

class _EffectUsageSection:
    def render(self) -> list[str]: ...

class _DepAskUsageRecord:
    effect_type: str
    key: str | None
    count: int
    first_context: EffectCreationContext | None

class CallFrame:
    kleisli: Any
    function_name: str
    args: tuple
    kwargs: dict[str, Any]
    depth: int
    created_at: EffectCreationContext | None

class _EnvironmentSection:
    def render(self) -> list[str]: ...

class ExecutionContext:
    env: dict[str, Any]
    state: dict[str, Any]
    log: BoundedLog
    graph: WGraph
    io_allowed: bool
    cache: dict[str, Any]
    effect_observations: list[EffectObservation]
    program_call_stack: list[CallFrame]
    def copy(self) -> ExecutionContext: ...
    def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext: ...

class _SummarySection:
    def render(self) -> list[str]: ...

class _LogSection:
    def render(self) -> list[str]: ...

class _ErrorSection:
    def render(self) -> list[str]: ...
    def _render_effect_entry(self, idx: int, entry: EffectFailureInfo, is_primary: bool) -> list[str]: ...
    def _render_effect_creation_details(self, entry: EffectFailureInfo, effect_name: str, is_primary: bool) -> list[str]: ...
    def _indent_creation_trace(self, trace_lines: list[str]) -> list[str]: ...
    def _render_effect_cause(self, entry: EffectFailureInfo) -> list[str]: ...
    def _render_runtime_trace(self, entry: EffectFailureInfo) -> list[str]: ...
    def _render_exception_entry(self, idx: int, entry: ExceptionFailureInfo) -> list[str]: ...
    def _render_trace(self, trace: CapturedTraceback, label: str) -> list[str]: ...

class RunResult(Generic[T]):
    context: ExecutionContext
    result: Result[T]
    def value(self) -> T: ...
    def is_ok(self) -> bool: ...
    def is_err(self) -> bool: ...
    def env(self) -> dict[str, Any]: ...
    def state(self) -> dict[str, Any]: ...
    def shared_state(self) -> dict[str, Any]: ...
    def log(self) -> list[Any]: ...
    def graph(self) -> WGraph: ...
    def effect_observations(self) -> list[EffectObservation]: ...
    def _failure_details(self) -> RunFailureDetails | None: ...
    def _failure_summary(self) -> str: ...
    def format_error(self, condensed: bool = ...) -> str: ...
    def _render_error_detail(self, error: Any, condensed: bool) -> str | None: ...
    def _format_effect_failure_error(self, error: EffectFailure, condensed: bool) -> str: ...
    def _format_exception_error(error: BaseException, condensed: bool) -> str: ...
    def formatted_error(self) -> str: ...
    def __repr__(self) -> str: ...
    def display(self, verbose: bool = ..., indent: int = ...) -> str: ...
    def visualize_graph_ascii(self, node_style: NodeStyle | str = ..., node_spacing: int = ..., margin: int = ..., layer_spacing: int = ..., show_arrows: bool = ..., use_ascii: bool | None = ..., max_value_length: int = ..., include_ops: bool = ..., custom_decorators: dict[WNode | str, tuple[str, str]] | None = ...) -> str: ...
    def _import_phart_dependencies() -> Any: ...
    def _build_base_graph(nx: Any, steps: Iterable[WStep]) -> tuple[Any, dict[WNode, WStep]]: ...
    def _build_label_map(self, nx: Any, base_graph: Any, producers: dict[WNode, WStep], include_ops: bool, max_value_length: int) -> dict[WNode, str]: ...
    def _preview_graph_value(value: Any, max_length: int) -> str: ...
    def _build_phart_graph(nx: Any, base_graph: Any, label_map: dict[WNode, str]) -> Any: ...
    def _resolve_graph_style(self, node_style: NodeStyle | str, custom_decorators: dict[WNode | str, tuple[str, str]] | None, label_map: dict[WNode, str], node_style_type: Any) -> tuple[Any, dict[str, tuple[str, str]] | None]: ...
    def _normalize_node_style(node_style: NodeStyle | str, node_style_type: Any) -> Any: ...
    def _prepare_decorators(custom_decorators: dict[WNode | str, tuple[str, str]] | None, label_map: dict[WNode, str]) -> dict[str, tuple[str, str]] | None: ...
    def _format_value(self, value: Any, max_length: int = ...) -> str: ...
    def _format_string_value(self, value: str, max_length: int) -> str: ...
    def _format_dict_value(self, value: dict[Any, Any], max_length: int) -> str: ...
    def _format_list_value(self, value: list[Any], max_length: int) -> str: ...
    def _format_object_value(self, value: Any, max_length: int) -> str: ...
    def _format_generic_value(self, value: Any, max_length: int) -> str: ...

class EffectCreationContext:
    filename: str
    line: int
    function: str
    code: str | None
    stack_trace: list[dict[str, Any]]
    frame_info: Any
    def format_location(self) -> str: ...
    def format_full(self) -> str: ...
    def build_traceback(self) -> str: ...
    def without_frames(self) -> EffectCreationContext: ...

class EffectFailureInfo:
    effect: Effect
    creation_context: EffectCreationContext | None
    cause: BaseException | None
    runtime_trace: CapturedTraceback | None
    cause_trace: CapturedTraceback | None

class EffectBase:
    created_at: EffectCreationContext | None
    def intercept(self: E, transform: Callable[Any, Effect | Program]) -> E: ...
    def with_created_at(self: E, created_at: EffectCreationContext | None) -> E: ...
    def to_generator(self) -> Generator[Effect | Program, Any, Any]: ...

class RunFailureDetails:
    entries: tuple[FailureEntry, Any]
    def from_error(cls, error: Any) -> RunFailureDetails | None: ...

# Additional symbols:
class _TracebackSplit:
    header: list[str]
    body: list[str]

class _HeadTailLengths:
    head_lines: int
    tail_lines: int

