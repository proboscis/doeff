from typing import Any

T: Any
logger: Any
__all__: Any

def _effect_is(effect: Effect, cls) -> bool: ...

def force_eval(prog: Program[T]) -> Program[T]: ...

class ProgramInterpreter:
    def __init__(
        self,
        custom_handlers: dict[str, Any] | None = ...,
        *,
        max_log_entries: int | None = ...,
    ) -> Any: ...
    def run(self, program: Program[T], context: ExecutionContext | None = ...) -> RunResult[T]: ...
    async def run_async(self, program: Program[T], context: ExecutionContext | None = ...) -> RunResult[T]: ...
    async def _execute_program_loop(self, program: Program[T], ctx: ExecutionContext) -> RunResult[T]: ...
    async def _try_reader_effects(self, effect: Effect, ctx: ExecutionContext) -> Any: ...
    async def _try_state_effects(self, effect: Effect, ctx: ExecutionContext) -> Any: ...
    async def _try_result_effects(self, effect: Effect, ctx: ExecutionContext) -> Any: ...
    async def _try_other_effects(self, effect: Effect, ctx: ExecutionContext) -> Any: ...
    async def _try_future_io_graph_effects(self, effect: Effect, ctx: ExecutionContext) -> Any: ...
    async def _try_gather_memo_cache_effects(self, effect: Effect, ctx: ExecutionContext) -> Any: ...
    def _record_effect_usage(self, effect: Effect, ctx: ExecutionContext) -> None: ...
    async def _handle_effect(self, effect: Effect, ctx: ExecutionContext) -> Any: ...
    async def _handle_gather_effect(self, effect: GatherEffect, ctx: ExecutionContext) -> Any: ...
    async def _handle_gather_dict_effect(self, effect: GatherDictEffect, ctx: ExecutionContext) -> Any: ...
    async def _run_gather_sequence(self, programs: list[Program], ctx: ExecutionContext) -> list[Any]: ...

_NO_HANDLER: Any
