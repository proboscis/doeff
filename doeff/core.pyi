from typing import (
    Any,
    Dict,
    List,
    Optional,
    Callable,
    Generator,
    ParamSpec,
    Tuple,
    Awaitable,
    TypeVar,
    Generic,
    Union,
)
from dataclasses import dataclass
from doeff._vendor import WGraph, Result

T = TypeVar("T")
U = TypeVar("U")
P = ParamSpec("P")

@dataclass(frozen=True)
class RunResult(Generic[T]):
    context: ExecutionContext
    result: Result[T]
    @property
    def value(self) -> T: ...
    @property
    def is_ok(self) -> bool: ...
    @property
    def is_err(self) -> bool: ...
    @property
    def graph(self) -> WGraph: ...
    @property
    def state(self) -> Dict[str, Any]: ...
    @property
    def log(self) -> List[Any]: ...
    @property
    def env(self) -> Dict[str, Any]: ...

class Effects:
    class reader:
        @staticmethod
        def ask(key: str) -> Effect: ...
        @staticmethod
        def local(env_update: Dict[str, Any], sub_program: Callable) -> Effect: ...

    class state:
        @staticmethod
        def get(key: str) -> Effect: ...
        @staticmethod
        def put(key: str, value: Any) -> Effect: ...
        @staticmethod
        def modify(key: str, f: Callable[Any, Any]) -> Effect: ...

    class writer:
        @staticmethod
        def tell(message: Any) -> Effect: ...
        @staticmethod
        def listen(sub_program: Callable) -> Effect: ...

    class future:
        @staticmethod
        def await_(awaitable: Awaitable[Any]) -> Effect: ...
        @staticmethod
        def parallel(*awaitables: Awaitable[Any]) -> Effect: ...

    class result:
        @staticmethod
        def fail(exc: Exception) -> Effect: ...
        @staticmethod
        def catch(
            sub_program: Callable, handler: Callable[Any, Generator]
        ) -> Effect: ...

    class io:
        @staticmethod
        def run(action: Callable[Any, Any]) -> Effect: ...
        @staticmethod
        def print(message: str) -> Effect: ...

    class graph:
        @staticmethod
        def step(value: Any, meta: Optional[Dict[str, Any]] = ...) -> Effect: ...
        @staticmethod
        def annotate(meta: Dict[str, Any]) -> Effect: ...

    class program:
        @staticmethod
        def gather(programs: List["Program"]) -> Effect: ...
        @staticmethod
        def gather_dict(programs: Dict[str, "Program"]) -> Effect: ...

# Capitalized aliases
def Ask(key: str) -> Effect: ...
def Local(env_update: Dict[str, Any], sub_program: Callable) -> Effect: ...
def Get(key: str) -> Effect: ...
def Put(key: str, value: Any) -> Effect: ...
def Modify(key: str, f: Callable[Any, Any]) -> Effect: ...
def Log(message: Any) -> Effect: ...
def Tell(message: Any) -> Effect: ...
def Listen(sub_program: Callable) -> Effect: ...
def Await(awaitable: Awaitable[Any]) -> Effect: ...
def Parallel(*awaitables: Awaitable[Any]) -> Effect: ...
def Fail(exc: Exception) -> Effect: ...
def Catch(sub_program: Callable, handler: Callable[Any, Generator]) -> Effect: ...
def IO(action: Callable[Any, Any]) -> Effect: ...
def Print(message: str) -> Effect: ...
def Step(value: Any, meta: Optional[Dict[str, Any]] = ...) -> Effect: ...
def Annotate(meta: Dict[str, Any]) -> Effect: ...
def Gather(programs: List["Program"]) -> Effect: ...
def GatherDict(programs: Dict[str, "Program"]) -> Effect: ...
def Dep(key: str) -> Effect: ...

# Backwards compatibility - lowercase
def ask(key: str) -> Effect: ...
def local(env_update: Dict[str, Any], sub_program: Callable) -> Effect: ...
def get(key: str) -> Effect: ...
def put(key: str, value: Any) -> Effect: ...
def modify(key: str, f: Callable[Any, Any]) -> Effect: ...
def tell(message: Any) -> Effect: ...
def listen(sub_program: Callable) -> Effect: ...
def await_(awaitable: Awaitable[Any]) -> Effect: ...
def parallel(*awaitables: Awaitable[Any]) -> Effect: ...
def fail(exc: Exception) -> Effect: ...
def catch(sub_program: Callable, handler: Callable[Any, Generator]) -> Effect: ...
def io(action: Callable[Any, Any]) -> Effect: ...
def print_(message: str) -> Effect: ...
def step(value: Any, meta: Optional[Dict[str, Any]] = ...) -> Effect: ...
def annotate(meta: Dict[str, Any]) -> Effect: ...
def do(
    func: Callable[P, Generator[Union[Effect, Program], Any, T]],
) -> KleisliProgram[P, T]: ...
def comprehensive_example() -> Program[Dict[str, Any]]: ...
async def fetch_data() -> list: ...
async def process_item(item: int) -> int: ...
def risky_computation() -> Program[Dict]: ...
def inner_computation() -> Program[str]: ...
def logged_computation() -> Program[int]: ...
async def main() -> Any: ...

class ProgramInterpreter:
    def __init__(self) -> None: ...
    async def run(
        self, program: Program[T], context: Optional[ExecutionContext] = ...
    ) -> RunResult[T]: ...
    async def _handle_effect(self, effect: Effect, ctx: ExecutionContext) -> Any: ...
    async def _dispatch_reader_ask(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_reader_local(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_state_get(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_state_put(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_state_modify(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_writer_tell(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_writer_listen(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_future_await(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_future_parallel(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_result_fail(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_result_catch(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_io_run(self, effect: Effect, ctx: ExecutionContext) -> Any: ...
    async def _dispatch_io_print(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_graph_step(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_graph_annotate(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Any: ...
    async def _dispatch_program_gather(
        self, effect: Effect, ctx: ExecutionContext
    ) -> List[Any]: ...
    async def _dispatch_program_gather_dict(
        self, effect: Effect, ctx: ExecutionContext
    ) -> Dict[str, Any]: ...

@dataclass(frozen=True)
class KleisliProgram(Generic[P, T]):
    func: Callable[P, "Program[T]"]
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> "Program[T]": ...

class Program(Generic[T]):
    generator_func: Callable[[], Generator[Union[Effect, "Program"], Any, T]]
    def __iter__(self) -> Generator[Union[Effect, "Program"], Any, T]: ...
    def map(self, f: Callable[[T], U]) -> "Program[U]": ...
    def flat_map(self, f: Callable[[T], "Program[U]"]) -> "Program[U]": ...
    @staticmethod
    def pure(value: T) -> "Program[T]": ...

class ExecutionContext:
    env: Dict[str, Any]
    io_allowed: bool
    state: Dict[str, Any]
    log: List[Any]
    graph: WGraph
    def copy(self) -> ExecutionContext: ...

class Effect:
    tag: str
    payload: Any

# Additional symbols:
class ResultEffectHandler:
    async def handle_fail(self, exc: Exception) -> None: ...
    async def handle_catch(
        self, payload: Dict, ctx: ExecutionContext, engine: "ProgramInterpreter"
    ) -> Any: ...

class IOEffectHandler:
    async def handle_run(
        self, action: Callable[Any, Any], ctx: ExecutionContext
    ) -> Any: ...
    async def handle_print(self, message: str, ctx: ExecutionContext) -> None: ...

class FutureEffectHandler:
    async def handle_await(self, awaitable: Awaitable[Any]) -> Any: ...
    async def handle_parallel(
        self, awaitables: Tuple[Awaitable[Any], Any]
    ) -> List[Any]: ...

class GraphEffectHandler:
    async def handle_step(self, payload: Dict, ctx: ExecutionContext) -> Any: ...
    async def handle_annotate(
        self, meta: Dict[str, Any], ctx: ExecutionContext
    ) -> None: ...

class StateEffectHandler:
    async def handle_get(self, key: str, ctx: ExecutionContext) -> Any: ...
    async def handle_put(self, payload: Dict, ctx: ExecutionContext) -> None: ...
    async def handle_modify(self, payload: Dict, ctx: ExecutionContext) -> Any: ...

class ReaderEffectHandler:
    async def handle_ask(self, key: str, ctx: ExecutionContext) -> Any: ...
    async def handle_local(
        self, payload: Dict, ctx: ExecutionContext, engine: "ProgramInterpreter"
    ) -> Any: ...

@dataclass(frozen=True)
class ListenResult:
    value: Any
    log: List[Any]
    def __iter__(self) -> Any: ...

class WriterEffectHandler:
    async def handle_tell(self, message: Any, ctx: ExecutionContext) -> None: ...
    async def handle_listen(
        self,
        sub_program_func: Callable,
        ctx: ExecutionContext,
        engine: "ProgramInterpreter",
    ) -> ListenResult: ...

# Additional symbols:

# Additional symbols:

# Additional symbols:
