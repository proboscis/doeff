{"timestamp":1765070411,"datetime":"2025-12-07T01:20:11Z","files_scanned":1,"total_violations":122,"error_count":1,"warning_count":105,"info_count":16,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":623,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'tasks'. Replace `tasks = []; for x in items: tasks.append(expr)` with `tasks = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for prog in normalized_programs:"},{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":642,"severity":"warning","message":"Consider refactoring: 'results' is initialized as empty list and populated via for-loop with 4 statements. Extract the loop body into a named function and use list comprehension: `results = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for sub_result in sub_results:"},{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":651,"severity":"warning","message":"Consider refactoring: 'gather_inputs' is initialized as empty list and populated via for-loop with 4 statements. Extract the loop body into a named function and use list comprehension: `gather_inputs = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for sub_ctx in sub_contexts:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":79,"severity":"info","message":"Function '_effect_is' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _effect_is(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _effect_is(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _effect_is(effect: Effect, cls) -> bool:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":92,"severity":"info","message":"Function 'force_eval' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def force_eval(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def force_eval(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def force_eval(prog: Program[T]) -> Program[T]:"},{"rule_id":"DOEFF009","file_path":"doeff/interpreter.py","line":99,"severity":"warning","message":"Function 'forced_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def forced_generator():"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":99,"severity":"info","message":"Function 'forced_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def forced_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def forced_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def forced_generator():"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":146,"severity":"warning","message":"Function parameter '__init__ (param 'custom_handlers')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, Any]]' or 'dict[str, Any] | None', use 'Maybe[dict[str, Any]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def __init__("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":146,"severity":"warning","message":"Function parameter '__init__ (param 'max_log_entries')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def __init__("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":214,"severity":"warning","message":"Function parameter 'run (param 'context')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[ExecutionContext]' or 'ExecutionContext | None', use 'Maybe[ExecutionContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def run("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":214,"severity":"info","message":"Method 'run' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def run(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def run(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def run("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":232,"severity":"warning","message":"Function parameter 'run_async (param 'context')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[ExecutionContext]' or 'ExecutionContext | None', use 'Maybe[ExecutionContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"async def run_async("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":232,"severity":"info","message":"Async method 'run_async' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  async def run_async(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  async def run_async(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"async def run_async("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":389,"severity":"warning","message":"Variable annotation 'effect_type' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"effect_type: str | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":390,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":604,"severity":"info","message":"Function '_enqueue_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _enqueue_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _enqueue_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _enqueue_program(prog_like: Any) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":640,"severity":"warning","message":"Variable annotation 'error_to_raise' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"error_to_raise: BaseException | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":671,"severity":"info","message":"Function '_build_intercept_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _build_intercept_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _build_intercept_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _build_intercept_program("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":694,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":684,"severity":"info","message":"Function '_intercept_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_generator("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":694,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"doeff/interpreter.py","line":701,"severity":"warning","message":"Function '_forward_exception' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _forward_exception(e: BaseException):"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":701,"severity":"info","message":"Function '_forward_exception' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _forward_exception(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _forward_exception(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _forward_exception(e: BaseException):"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":783,"severity":"info","message":"Function '_compose_intercept_transforms' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _compose_intercept_transforms(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _compose_intercept_transforms(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _compose_intercept_transforms("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":791,"severity":"info","message":"Function 'combined' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def combined(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def combined(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def combined(effect: EffectBase) -> Program[EffectBase]:"},{"rule_id":"DOEFF020","file_path":"doeff/interpreter.py","line":792,"severity":"info","message":"Program variable 'program' should use 'p_' prefix.\n\nNaming convention: Program type variables should be named with 'p_' prefix for consistency and brevity.\n\nFix: Rename the variable:\n  # Before\n  program: Program = ...\n  \n  # After\n  p_program: Program = ...","source_line":"program: Program[EffectBase] = Program.pure(effect)"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":800,"severity":"info","message":"Function '_lift_intercept_transform' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _lift_intercept_transform(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _lift_intercept_transform(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _lift_intercept_transform("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":806,"severity":"info","message":"Function 'lifted' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lifted(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lifted(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lifted(effect: EffectBase) -> Program:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":823,"severity":"info","message":"Function '_ensure_effect_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _ensure_effect_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _ensure_effect_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _ensure_effect_program(value: Any) -> Program:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":835,"severity":"info","message":"Function '_program_to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _program_to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _program_to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _program_to_generator("},{"rule_id":"DOEFF021","file_path":"doeff/interpreter.py","line":855,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = [\"ProgramInterpreter\", \"force_eval\"]"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765070453,"datetime":"2025-12-07T01:20:53Z","files_scanned":6,"total_violations":372,"error_count":3,"warning_count":308,"info_count":61,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":623,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'tasks'. Replace `tasks = []; for x in items: tasks.append(expr)` with `tasks = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for prog in normalized_programs:"},{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":642,"severity":"warning","message":"Consider refactoring: 'results' is initialized as empty list and populated via for-loop with 4 statements. Extract the loop body into a named function and use list comprehension: `results = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for sub_result in sub_results:"},{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":651,"severity":"warning","message":"Consider refactoring: 'gather_inputs' is initialized as empty list and populated via for-loop with 4 statements. Extract the loop body into a named function and use list comprehension: `gather_inputs = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for sub_ctx in sub_contexts:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":79,"severity":"info","message":"Function '_effect_is' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _effect_is(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _effect_is(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _effect_is(effect: Effect, cls) -> bool:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":92,"severity":"info","message":"Function 'force_eval' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def force_eval(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def force_eval(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def force_eval(prog: Program[T]) -> Program[T]:"},{"rule_id":"DOEFF009","file_path":"doeff/interpreter.py","line":99,"severity":"warning","message":"Function 'forced_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def forced_generator():"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":99,"severity":"info","message":"Function 'forced_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def forced_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def forced_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def forced_generator():"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":146,"severity":"warning","message":"Function parameter '__init__ (param 'custom_handlers')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, Any]]' or 'dict[str, Any] | None', use 'Maybe[dict[str, Any]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def __init__("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":146,"severity":"warning","message":"Function parameter '__init__ (param 'max_log_entries')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def __init__("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":214,"severity":"warning","message":"Function parameter 'run (param 'context')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[ExecutionContext]' or 'ExecutionContext | None', use 'Maybe[ExecutionContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def run("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":214,"severity":"info","message":"Method 'run' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def run(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def run(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def run("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":232,"severity":"warning","message":"Function parameter 'run_async (param 'context')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[ExecutionContext]' or 'ExecutionContext | None', use 'Maybe[ExecutionContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"async def run_async("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":232,"severity":"info","message":"Async method 'run_async' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  async def run_async(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  async def run_async(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"async def run_async("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":389,"severity":"warning","message":"Variable annotation 'effect_type' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"effect_type: str | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":390,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":604,"severity":"info","message":"Function '_enqueue_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _enqueue_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _enqueue_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _enqueue_program(prog_like: Any) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":640,"severity":"warning","message":"Variable annotation 'error_to_raise' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"error_to_raise: BaseException | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":671,"severity":"info","message":"Function '_build_intercept_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _build_intercept_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _build_intercept_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _build_intercept_program("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":694,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":684,"severity":"info","message":"Function '_intercept_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_generator("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":694,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":701,"severity":"info","message":"Function '_forward_exception' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _forward_exception(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _forward_exception(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _forward_exception(e: BaseException) -> bool | T:  # noqa: DOEFF014"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":783,"severity":"info","message":"Function '_compose_intercept_transforms' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _compose_intercept_transforms(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _compose_intercept_transforms(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _compose_intercept_transforms("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":791,"severity":"info","message":"Function 'combined' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def combined(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def combined(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def combined(effect: EffectBase) -> Program[EffectBase]:"},{"rule_id":"DOEFF020","file_path":"doeff/interpreter.py","line":792,"severity":"info","message":"Program variable 'program' should use 'p_' prefix.\n\nNaming convention: Program type variables should be named with 'p_' prefix for consistency and brevity.\n\nFix: Rename the variable:\n  # Before\n  program: Program = ...\n  \n  # After\n  p_program: Program = ...","source_line":"program: Program[EffectBase] = Program.pure(effect)"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":800,"severity":"info","message":"Function '_lift_intercept_transform' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _lift_intercept_transform(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _lift_intercept_transform(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _lift_intercept_transform("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":806,"severity":"info","message":"Function 'lifted' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lifted(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lifted(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lifted(effect: EffectBase) -> Program:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":823,"severity":"info","message":"Function '_ensure_effect_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _ensure_effect_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _ensure_effect_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _ensure_effect_program(value: Any) -> Program:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":835,"severity":"info","message":"Function '_program_to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _program_to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _program_to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _program_to_generator("},{"rule_id":"DOEFF021","file_path":"doeff/interpreter.py","line":855,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = [\"ProgramInterpreter\", \"force_eval\"]"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":66,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":66,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/do.py","line":28,"severity":"info","message":"Function 'generator_wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def generator_wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def generator_wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def generator_wrapper("},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":66,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/do.py","line":80,"severity":"info","message":"Function 'do' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def do(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def do(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def do("},{"rule_id":"DOEFF021","file_path":"doeff/do.py","line":161,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = [\"do\", \"DoYieldFunction\"]"},{"rule_id":"DOEFF012","file_path":"doeff/program.py","line":499,"severity":"warning","message":"Consider refactoring: 'program_indices' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `program_indices = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for index, arg in enumerate(args_tuple):"},{"rule_id":"DOEFF012","file_path":"doeff/program.py","line":499,"severity":"warning","message":"Consider refactoring: 'program_args' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `program_args = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for index, arg in enumerate(args_tuple):"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":44,"severity":"warning","message":"Variable annotation 'variable' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"self.var_positional: bool | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":46,"severity":"warning","message":"Variable annotation 'variable' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"self.var_keyword: bool | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":48,"severity":"info","message":"Method 'should_unwrap_positional' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def should_unwrap_positional(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def should_unwrap_positional(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def should_unwrap_positional(self, index: int) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":55,"severity":"info","message":"Method 'should_unwrap_keyword' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def should_unwrap_keyword(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def should_unwrap_keyword(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def should_unwrap_keyword(self, name: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":63,"severity":"info","message":"Function '_string_annotation_is_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _string_annotation_is_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _string_annotation_is_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _string_annotation_is_program(annotation_text: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":89,"severity":"info","message":"Function '_string_annotation_is_effect' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _string_annotation_is_effect(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _string_annotation_is_effect(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _string_annotation_is_effect(annotation_text: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":117,"severity":"info","message":"Function '_annotation_is_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _annotation_is_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _annotation_is_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _annotation_is_program(annotation: Any) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":143,"severity":"info","message":"Function '_annotation_is_effect' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _annotation_is_effect(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _annotation_is_effect(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _annotation_is_effect(annotation: Any) -> bool:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":171,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":168,"severity":"info","message":"Function '_safe_get_type_hints' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _safe_get_type_hints(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _safe_get_type_hints(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _safe_get_type_hints(target: Any) -> dict[str, Any]:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":171,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":178,"severity":"warning","message":"Function return type '_safe_signature' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[inspect.Signature]' or 'inspect.Signature | None', use 'Maybe[inspect.Signature]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _safe_signature(target: Any) -> inspect.Signature | None:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":179,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":178,"severity":"info","message":"Function '_safe_signature' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _safe_signature(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _safe_signature(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _safe_signature(target: Any) -> inspect.Signature | None:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":179,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":185,"severity":"info","message":"Function '_build_auto_unwrap_strategy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _build_auto_unwrap_strategy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _build_auto_unwrap_strategy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _build_auto_unwrap_strategy(kleisli: Any) -> _AutoUnwrapStrategy:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":220,"severity":"warning","message":"Method '__class_getitem__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __class_getitem__(cls, item):"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":230,"severity":"info","message":"Function 'mapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def mapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def mapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def mapper(value: Any) -> Any:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":248,"severity":"info","message":"Function 'invoke_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def invoke_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def invoke_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def invoke_callable(func: Any) -> Program[Any]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":256,"severity":"info","message":"Function 'gather_inputs' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def gather_inputs(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def gather_inputs(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def gather_inputs() -> Generator[Effect | Program, Any, tuple[list[Any], dict[str, Any]]]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":261,"severity":"info","message":"Function 'call_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def call_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def call_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def call_program() -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":272,"severity":"warning","message":"Function 'map' shadows Python built-in 'map'. Use a more descriptive name like 'map_impl' or 'create_map'.","source_line":"def map(self, f: Callable[[T], U]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":272,"severity":"info","message":"Method 'map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def map(self, f: Callable[[T], U]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":278,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":284,"severity":"info","message":"Method 'flat_map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flat_map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flat_map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flat_map(self, f: Callable[[T], Program[U]]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":290,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":303,"severity":"info","message":"Method 'and_then_k' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def and_then_k(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def and_then_k(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def and_then_k(self, binder: Callable[[T], Program[U]]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":308,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":341,"severity":"warning","message":"Function 'first_success_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def first_success_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":341,"severity":"info","message":"Function 'first_success_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def first_success_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def first_success_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def first_success_generator():"},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":355,"severity":"warning","message":"Function 'first_some_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def first_some_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":355,"severity":"info","message":"Function 'first_some_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def first_some_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def first_some_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def first_some_generator():"},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":378,"severity":"warning","message":"Function 'sequence_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def sequence_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":378,"severity":"info","message":"Function 'sequence_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def sequence_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def sequence_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def sequence_generator():"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":394,"severity":"warning","message":"Function 'list' shadows Python built-in 'list'. Use a more descriptive name like 'list_impl' or 'create_list'.","source_line":"def list(*values: Iterable[Program[U] | U]) -> Program[list[U]]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":399,"severity":"warning","message":"Function 'tuple' shadows Python built-in 'tuple'. Use a more descriptive name like 'tuple_impl' or 'create_tuple'.","source_line":"def tuple(*values: Iterable[Program[U] | U]) -> Program[tuple[U, ...]]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":403,"severity":"warning","message":"Function 'set' shadows Python built-in 'set'. Use a more descriptive name like 'set_impl' or 'create_set'.","source_line":"def set(*values: Iterable[Program[U] | U]) -> Program[set[U]]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":407,"severity":"warning","message":"Function 'dict' shadows Python built-in 'dict'. Use a more descriptive name like 'dict_impl' or 'create_dict'.","source_line":"def dict("},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":415,"severity":"warning","message":"Function 'dict_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def dict_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":415,"severity":"info","message":"Function 'dict_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def dict_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def dict_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def dict_generator():"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":432,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[Any]' or 'Any | None', use 'Maybe[Any]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: Any | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":434,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":445,"severity":"warning","message":"Function 'map' shadows Python built-in 'map'. Use a more descriptive name like 'map_impl' or 'create_map'.","source_line":"def map(self, f: Callable[[T], U]) -> ProgramProtocol[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":445,"severity":"info","message":"Method 'map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def map(self, f: Callable[[T], U]) -> ProgramProtocol[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":449,"severity":"info","message":"Method 'flat_map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flat_map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flat_map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flat_map(self, f: Callable[[T], ProgramProtocol[U]]) -> ProgramProtocol[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":453,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":470,"severity":"warning","message":"Variable annotation 'auto_unwrap_strategy' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[_AutoUnwrapStrategy]' or '_AutoUnwrapStrategy | None', use 'Maybe[_AutoUnwrapStrategy]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"auto_unwrap_strategy: _AutoUnwrapStrategy | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":471,"severity":"warning","message":"Variable annotation 'execution_kernel' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[Callable[T, Generator[T, Any, T]]]' or 'Callable[T, Generator[T, Any, T]] | None', use 'Maybe[Callable[T, Generator[T, Any, T]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"execution_kernel: Callable[..., Generator[Effect | Program, Any, T]] | None = None"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":473,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":494,"severity":"info","message":"Function 'generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def generator() -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":582,"severity":"warning","message":"Function parameter 'create_derived (param 'args')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[tuple]' or 'tuple | None', use 'Maybe[tuple]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def create_derived("},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":582,"severity":"warning","message":"Function parameter 'create_derived (param 'kwargs')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, Any]]' or 'dict[str, Any] | None', use 'Maybe[dict[str, Any]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def create_derived("},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":602,"severity":"warning","message":"Function 'map' shadows Python built-in 'map'. Use a more descriptive name like 'map_impl' or 'create_map'.","source_line":"def map(self, f: Callable[[T], U]) -> KleisliProgramCall[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":602,"severity":"info","message":"Method 'map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def map(self, f: Callable[[T], U]) -> KleisliProgramCall[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":605,"severity":"info","message":"Function 'mapped_gen' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def mapped_gen(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def mapped_gen(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def mapped_gen(*_args: Any, **_kwargs: Any) -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":611,"severity":"info","message":"Method 'flat_map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flat_map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flat_map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flat_map(self, f: Callable[[T], ProgramProtocol[U]]) -> KleisliProgramCall[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":614,"severity":"info","message":"Function 'flatmapped_gen' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flatmapped_gen(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flatmapped_gen(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flatmapped_gen(*_args: Any, **_kwargs: Any) -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF020","file_path":"doeff/program.py","line":628,"severity":"warning","message":"Program variable 'base_program' uses deprecated '_program' suffix.\n\nNaming convention: Program type variables should be named with 'p_' prefix instead of '_program' suffix for consistency and brevity.\n\nFix: Rename the variable:\n  # Before\n  base_program: Program = ...\n  \n  # After\n  p_base: Program = ...","source_line":"base_program: Program[T]"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":631,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":634,"severity":"info","message":"Function 'generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def generator() -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":659,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF021","file_path":"doeff/program.py","line":669,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = [\"GeneratorProgram\", \"KleisliProgramCall\", \"Program\", \"ProgramProtocol\"]"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":35,"severity":"warning","message":"Async function 'test_recover_with_fallback_value' is missing a return type annotation.","source_line":"async def test_recover_with_fallback_value():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":61,"severity":"warning","message":"Async function 'test_recover_with_fallback_program' is missing a return type annotation.","source_line":"async def test_recover_with_fallback_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":89,"severity":"warning","message":"Async function 'test_recover_on_success' is missing a return type annotation.","source_line":"async def test_recover_on_success():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":114,"severity":"warning","message":"Async function 'test_retry_success_on_second_attempt' is missing a return type annotation.","source_line":"async def test_retry_success_on_second_attempt():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":149,"severity":"warning","message":"Async function 'test_retry_max_attempts_exceeded' is missing a return type annotation.","source_line":"async def test_retry_max_attempts_exceeded():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":174,"severity":"warning","message":"Async function 'test_retry_with_delay' is missing a return type annotation.","source_line":"async def test_retry_with_delay():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":221,"severity":"warning","message":"Async function 'test_retry_with_delay_strategy' is missing a return type annotation.","source_line":"async def test_retry_with_delay_strategy(monkeypatch):"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":226,"severity":"warning","message":"Async function 'fake_sleep' is missing a return type annotation.","source_line":"async def fake_sleep(duration: float):"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":226,"severity":"info","message":"Async function 'fake_sleep' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  async def fake_sleep(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  async def fake_sleep(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"async def fake_sleep(duration: float):"},{"rule_id":"DOEFF013","file_path":"tests/test_error_handling_effects.py","line":233,"severity":"warning","message":"Function parameter 'delay_strategy (param 'error')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[Exception]' or 'Exception | None', use 'Maybe[Exception]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def delay_strategy(attempt: int, error: Exception | None) -> float:"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":233,"severity":"info","message":"Function 'delay_strategy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def delay_strategy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def delay_strategy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def delay_strategy(attempt: int, error: Exception | None) -> float:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":266,"severity":"warning","message":"Async function 'test_nested_error_handling' is missing a return type annotation.","source_line":"async def test_nested_error_handling():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":294,"severity":"warning","message":"Async function 'test_catch_vs_recover' is missing a return type annotation.","source_line":"async def test_catch_vs_recover():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":331,"severity":"warning","message":"Async function 'test_catch_handler_logs_are_accumulated' is missing a return type annotation.","source_line":"async def test_catch_handler_logs_are_accumulated():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":359,"severity":"warning","message":"Async function 'test_catch_handler_logs_with_listen' is missing a return type annotation.","source_line":"async def test_catch_handler_logs_with_listen():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":389,"severity":"warning","message":"Async function 'test_catch_handler_fail_propagates_error_logs' is missing a return type annotation.","source_line":"async def test_catch_handler_fail_propagates_error_logs():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":423,"severity":"warning","message":"Async function 'test_catch_within_local_propagates_logs' is missing a return type annotation.","source_line":"async def test_catch_within_local_propagates_logs():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":457,"severity":"warning","message":"Async function 'test_retry_of_catch_preserves_attempt_logs' is missing a return type annotation.","source_line":"async def test_retry_of_catch_preserves_attempt_logs():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":501,"severity":"warning","message":"Async function 'test_why_try_except_doesnt_work' is missing a return type annotation.","source_line":"async def test_why_try_except_doesnt_work():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":536,"severity":"warning","message":"Async function 'test_recover_with_io_effect' is missing a return type annotation.","source_line":"async def test_recover_with_io_effect():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":542,"severity":"warning","message":"Function 'failing_io' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def failing_io():"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":542,"severity":"info","message":"Function 'failing_io' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def failing_io(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def failing_io(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def failing_io():"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":652,"severity":"info","message":"Function 'finalizer_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def finalizer_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def finalizer_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def finalizer_callable() -> None:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":700,"severity":"warning","message":"Async function 'test_native_try_except_catches_effect_error' is missing a return type annotation.","source_line":"async def test_native_try_except_catches_effect_error():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":705,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":705,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":705,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":719,"severity":"warning","message":"Async function 'test_native_try_except_catches_subprogram_error' is missing a return type annotation.","source_line":"async def test_native_try_except_catches_subprogram_error():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":729,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":729,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":729,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":743,"severity":"warning","message":"Async function 'test_nested_try_except' is missing a return type annotation.","source_line":"async def test_nested_try_except():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":748,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":748,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":748,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":765,"severity":"warning","message":"Async function 'test_try_finally_executes_on_exception' is missing a return type annotation.","source_line":"async def test_try_finally_executes_on_exception():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":772,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":772,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":772,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":789,"severity":"warning","message":"Async function 'test_uncaught_exception_becomes_err' is missing a return type annotation.","source_line":"async def test_uncaught_exception_becomes_err():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":794,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":794,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":794,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":810,"severity":"warning","message":"Async function 'test_exception_reraise' is missing a return type annotation.","source_line":"async def test_exception_reraise():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":815,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":815,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":815,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":830,"severity":"warning","message":"Async function 'test_safe_catch_recover_still_work' is missing a return type annotation.","source_line":"async def test_safe_catch_recover_still_work():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":842,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":842,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":842,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":858,"severity":"warning","message":"Async function 'test_try_except_with_multiple_yields' is missing a return type annotation.","source_line":"async def test_try_except_with_multiple_yields():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":864,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":864,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":864,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":884,"severity":"warning","message":"Async function 'test_try_except_with_state_effects' is missing a return type annotation.","source_line":"async def test_try_except_with_state_effects():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":891,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":891,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":891,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":907,"severity":"warning","message":"Async function 'test_try_except_with_log_effects' is missing a return type annotation.","source_line":"async def test_try_except_with_log_effects():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":914,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":914,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":914,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":933,"severity":"warning","message":"Async function 'test_try_except_with_io_effect' is missing a return type annotation.","source_line":"async def test_try_except_with_io_effect():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":941,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":941,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":938,"severity":"info","message":"Function 'failing_io' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def failing_io(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def failing_io(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def failing_io() -> None:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":941,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":955,"severity":"warning","message":"Async function 'test_try_except_with_nested_subprograms' is missing a return type annotation.","source_line":"async def test_try_except_with_nested_subprograms():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":975,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":975,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":975,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":989,"severity":"warning","message":"Async function 'test_try_except_with_recover_fallback' is missing a return type annotation.","source_line":"async def test_try_except_with_recover_fallback():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1001,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1001,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1001,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1023,"severity":"warning","message":"Async function 'test_try_except_inside_catch_handler' is missing a return type annotation.","source_line":"async def test_try_except_inside_catch_handler():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1028,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1028,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1028,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1051,"severity":"warning","message":"Async function 'test_try_except_with_finally_and_effects' is missing a return type annotation.","source_line":"async def test_try_except_with_finally_and_effects():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1058,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1058,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1058,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1078,"severity":"warning","message":"Async function 'test_try_except_preserves_context' is missing a return type annotation.","source_line":"async def test_try_except_preserves_context():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1085,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1085,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1085,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1103,"severity":"warning","message":"Async function 'test_multiple_try_except_blocks' is missing a return type annotation.","source_line":"async def test_multiple_try_except_blocks():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1110,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1115,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1120,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1110,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1115,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1120,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1110,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1115,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1120,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1135,"severity":"warning","message":"Async function 'test_try_except_with_safe_effect' is missing a return type annotation.","source_line":"async def test_try_except_with_safe_effect():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1145,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1145,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1145,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF012","file_path":"tests/test_yield_program.py","line":252,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'results'. Replace `results = []; for x in items: results.append(expr)` with `results = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for _ in range(3):"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":113,"severity":"warning","message":"Async function 'test_basic_program_yield' is missing a return type annotation.","source_line":"async def test_basic_program_yield():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":139,"severity":"warning","message":"Async function 'test_deeply_nested_yields' is missing a return type annotation.","source_line":"async def test_deeply_nested_yields():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":157,"severity":"warning","message":"Async function 'test_mixed_yields' is missing a return type annotation.","source_line":"async def test_mixed_yields():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":188,"severity":"warning","message":"Async function 'test_program_yield_with_error' is missing a return type annotation.","source_line":"async def test_program_yield_with_error():"},{"rule_id":"DOEFF014","file_path":"tests/test_yield_program.py","line":198,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_yield_program.py","line":198,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_yield_program.py","line":198,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":234,"severity":"warning","message":"Async function 'test_state_threading_through_programs' is missing a return type annotation.","source_line":"async def test_state_threading_through_programs():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":271,"severity":"warning","message":"Async function 'main' is missing a return type annotation.","source_line":"async def main():"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":20,"severity":"warning","message":"Async function 'test_fail_effect_with_creation_trace' is missing a return type annotation.","source_line":"async def test_fail_effect_with_creation_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":31,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":31,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":63,"severity":"warning","message":"Async function 'test_ask_effect_missing_key_with_trace' is missing a return type annotation.","source_line":"async def test_ask_effect_missing_key_with_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":74,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":74,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":103,"severity":"warning","message":"Async function 'test_effect_creation_trace_disabled' is missing a return type annotation.","source_line":"async def test_effect_creation_trace_disabled():"},{"rule_id":"DOEFF022","file_path":"tests/test_effect_creation_trace.py","line":112,"severity":"info","message":"Function 'simple_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def simple_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def simple_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def simple_program() -> EffectGenerator[str]:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":132,"severity":"warning","message":"Async function 'test_nested_program_creation_trace' is missing a return type annotation.","source_line":"async def test_nested_program_creation_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":142,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":142,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":176,"severity":"warning","message":"Async function 'test_effect_creation_context_structure' is missing a return type annotation.","source_line":"async def test_effect_creation_context_structure():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":186,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":186,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"tests/test_effect_creation_trace.py","line":187,"severity":"info","message":"Function 'program_with_effect' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def program_with_effect(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def program_with_effect(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def program_with_effect() -> EffectGenerator[str]:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":225,"severity":"warning","message":"Async function 'test_display_with_creation_trace' is missing a return type annotation.","source_line":"async def test_display_with_creation_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":243,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":243,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":295,"severity":"warning","message":"Async function 'test_nested_effect_error_chain' is missing a return type annotation.","source_line":"async def test_nested_effect_error_chain():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765070459,"datetime":"2025-12-07T01:20:59Z","files_scanned":6,"total_violations":372,"error_count":3,"warning_count":308,"info_count":61,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":623,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'tasks'. Replace `tasks = []; for x in items: tasks.append(expr)` with `tasks = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for prog in normalized_programs:"},{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":642,"severity":"warning","message":"Consider refactoring: 'results' is initialized as empty list and populated via for-loop with 4 statements. Extract the loop body into a named function and use list comprehension: `results = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for sub_result in sub_results:"},{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":651,"severity":"warning","message":"Consider refactoring: 'gather_inputs' is initialized as empty list and populated via for-loop with 4 statements. Extract the loop body into a named function and use list comprehension: `gather_inputs = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for sub_ctx in sub_contexts:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":79,"severity":"info","message":"Function '_effect_is' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _effect_is(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _effect_is(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _effect_is(effect: Effect, cls) -> bool:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":92,"severity":"info","message":"Function 'force_eval' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def force_eval(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def force_eval(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def force_eval(prog: Program[T]) -> Program[T]:"},{"rule_id":"DOEFF009","file_path":"doeff/interpreter.py","line":99,"severity":"warning","message":"Function 'forced_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def forced_generator():"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":99,"severity":"info","message":"Function 'forced_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def forced_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def forced_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def forced_generator():"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":146,"severity":"warning","message":"Function parameter '__init__ (param 'custom_handlers')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, Any]]' or 'dict[str, Any] | None', use 'Maybe[dict[str, Any]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def __init__("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":146,"severity":"warning","message":"Function parameter '__init__ (param 'max_log_entries')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def __init__("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":214,"severity":"warning","message":"Function parameter 'run (param 'context')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[ExecutionContext]' or 'ExecutionContext | None', use 'Maybe[ExecutionContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def run("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":214,"severity":"info","message":"Method 'run' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def run(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def run(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def run("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":232,"severity":"warning","message":"Function parameter 'run_async (param 'context')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[ExecutionContext]' or 'ExecutionContext | None', use 'Maybe[ExecutionContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"async def run_async("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":232,"severity":"info","message":"Async method 'run_async' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  async def run_async(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  async def run_async(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"async def run_async("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":389,"severity":"warning","message":"Variable annotation 'effect_type' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"effect_type: str | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":390,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":604,"severity":"info","message":"Function '_enqueue_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _enqueue_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _enqueue_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _enqueue_program(prog_like: Any) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":640,"severity":"warning","message":"Variable annotation 'error_to_raise' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"error_to_raise: BaseException | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":671,"severity":"info","message":"Function '_build_intercept_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _build_intercept_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _build_intercept_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _build_intercept_program("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":694,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":684,"severity":"info","message":"Function '_intercept_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_generator("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":694,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":701,"severity":"info","message":"Function '_forward_exception' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _forward_exception(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _forward_exception(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _forward_exception(e: BaseException) -> bool | T:  # noqa: DOEFF014"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":783,"severity":"info","message":"Function '_compose_intercept_transforms' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _compose_intercept_transforms(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _compose_intercept_transforms(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _compose_intercept_transforms("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":791,"severity":"info","message":"Function 'combined' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def combined(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def combined(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def combined(effect: EffectBase) -> Program[EffectBase]:"},{"rule_id":"DOEFF020","file_path":"doeff/interpreter.py","line":792,"severity":"info","message":"Program variable 'program' should use 'p_' prefix.\n\nNaming convention: Program type variables should be named with 'p_' prefix for consistency and brevity.\n\nFix: Rename the variable:\n  # Before\n  program: Program = ...\n  \n  # After\n  p_program: Program = ...","source_line":"program: Program[EffectBase] = Program.pure(effect)"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":800,"severity":"info","message":"Function '_lift_intercept_transform' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _lift_intercept_transform(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _lift_intercept_transform(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _lift_intercept_transform("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":806,"severity":"info","message":"Function 'lifted' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lifted(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lifted(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lifted(effect: EffectBase) -> Program:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":823,"severity":"info","message":"Function '_ensure_effect_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _ensure_effect_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _ensure_effect_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _ensure_effect_program(value: Any) -> Program:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":835,"severity":"info","message":"Function '_program_to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _program_to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _program_to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _program_to_generator("},{"rule_id":"DOEFF021","file_path":"doeff/interpreter.py","line":855,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = [\"ProgramInterpreter\", \"force_eval\"]"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":66,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":66,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/do.py","line":28,"severity":"info","message":"Function 'generator_wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def generator_wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def generator_wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def generator_wrapper("},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":66,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/do.py","line":80,"severity":"info","message":"Function 'do' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def do(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def do(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def do("},{"rule_id":"DOEFF021","file_path":"doeff/do.py","line":161,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = [\"do\", \"DoYieldFunction\"]"},{"rule_id":"DOEFF012","file_path":"doeff/program.py","line":499,"severity":"warning","message":"Consider refactoring: 'program_args' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `program_args = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for index, arg in enumerate(args_tuple):"},{"rule_id":"DOEFF012","file_path":"doeff/program.py","line":499,"severity":"warning","message":"Consider refactoring: 'program_indices' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `program_indices = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for index, arg in enumerate(args_tuple):"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":44,"severity":"warning","message":"Variable annotation 'variable' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"self.var_positional: bool | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":46,"severity":"warning","message":"Variable annotation 'variable' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"self.var_keyword: bool | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":48,"severity":"info","message":"Method 'should_unwrap_positional' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def should_unwrap_positional(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def should_unwrap_positional(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def should_unwrap_positional(self, index: int) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":55,"severity":"info","message":"Method 'should_unwrap_keyword' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def should_unwrap_keyword(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def should_unwrap_keyword(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def should_unwrap_keyword(self, name: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":63,"severity":"info","message":"Function '_string_annotation_is_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _string_annotation_is_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _string_annotation_is_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _string_annotation_is_program(annotation_text: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":89,"severity":"info","message":"Function '_string_annotation_is_effect' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _string_annotation_is_effect(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _string_annotation_is_effect(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _string_annotation_is_effect(annotation_text: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":117,"severity":"info","message":"Function '_annotation_is_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _annotation_is_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _annotation_is_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _annotation_is_program(annotation: Any) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":143,"severity":"info","message":"Function '_annotation_is_effect' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _annotation_is_effect(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _annotation_is_effect(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _annotation_is_effect(annotation: Any) -> bool:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":171,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":168,"severity":"info","message":"Function '_safe_get_type_hints' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _safe_get_type_hints(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _safe_get_type_hints(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _safe_get_type_hints(target: Any) -> dict[str, Any]:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":171,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":178,"severity":"warning","message":"Function return type '_safe_signature' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[inspect.Signature]' or 'inspect.Signature | None', use 'Maybe[inspect.Signature]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _safe_signature(target: Any) -> inspect.Signature | None:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":179,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":178,"severity":"info","message":"Function '_safe_signature' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _safe_signature(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _safe_signature(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _safe_signature(target: Any) -> inspect.Signature | None:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":179,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":185,"severity":"info","message":"Function '_build_auto_unwrap_strategy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _build_auto_unwrap_strategy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _build_auto_unwrap_strategy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _build_auto_unwrap_strategy(kleisli: Any) -> _AutoUnwrapStrategy:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":220,"severity":"warning","message":"Method '__class_getitem__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __class_getitem__(cls, item):"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":230,"severity":"info","message":"Function 'mapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def mapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def mapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def mapper(value: Any) -> Any:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":248,"severity":"info","message":"Function 'invoke_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def invoke_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def invoke_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def invoke_callable(func: Any) -> Program[Any]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":256,"severity":"info","message":"Function 'gather_inputs' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def gather_inputs(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def gather_inputs(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def gather_inputs() -> Generator[Effect | Program, Any, tuple[list[Any], dict[str, Any]]]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":261,"severity":"info","message":"Function 'call_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def call_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def call_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def call_program() -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":272,"severity":"warning","message":"Function 'map' shadows Python built-in 'map'. Use a more descriptive name like 'map_impl' or 'create_map'.","source_line":"def map(self, f: Callable[[T], U]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":272,"severity":"info","message":"Method 'map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def map(self, f: Callable[[T], U]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":278,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":284,"severity":"info","message":"Method 'flat_map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flat_map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flat_map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flat_map(self, f: Callable[[T], Program[U]]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":290,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":303,"severity":"info","message":"Method 'and_then_k' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def and_then_k(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def and_then_k(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def and_then_k(self, binder: Callable[[T], Program[U]]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":308,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":341,"severity":"warning","message":"Function 'first_success_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def first_success_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":341,"severity":"info","message":"Function 'first_success_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def first_success_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def first_success_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def first_success_generator():"},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":355,"severity":"warning","message":"Function 'first_some_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def first_some_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":355,"severity":"info","message":"Function 'first_some_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def first_some_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def first_some_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def first_some_generator():"},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":378,"severity":"warning","message":"Function 'sequence_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def sequence_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":378,"severity":"info","message":"Function 'sequence_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def sequence_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def sequence_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def sequence_generator():"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":394,"severity":"warning","message":"Function 'list' shadows Python built-in 'list'. Use a more descriptive name like 'list_impl' or 'create_list'.","source_line":"def list(*values: Iterable[Program[U] | U]) -> Program[list[U]]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":399,"severity":"warning","message":"Function 'tuple' shadows Python built-in 'tuple'. Use a more descriptive name like 'tuple_impl' or 'create_tuple'.","source_line":"def tuple(*values: Iterable[Program[U] | U]) -> Program[tuple[U, ...]]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":403,"severity":"warning","message":"Function 'set' shadows Python built-in 'set'. Use a more descriptive name like 'set_impl' or 'create_set'.","source_line":"def set(*values: Iterable[Program[U] | U]) -> Program[set[U]]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":407,"severity":"warning","message":"Function 'dict' shadows Python built-in 'dict'. Use a more descriptive name like 'dict_impl' or 'create_dict'.","source_line":"def dict("},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":415,"severity":"warning","message":"Function 'dict_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def dict_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":415,"severity":"info","message":"Function 'dict_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def dict_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def dict_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def dict_generator():"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":432,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[Any]' or 'Any | None', use 'Maybe[Any]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: Any | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":434,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":445,"severity":"warning","message":"Function 'map' shadows Python built-in 'map'. Use a more descriptive name like 'map_impl' or 'create_map'.","source_line":"def map(self, f: Callable[[T], U]) -> ProgramProtocol[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":445,"severity":"info","message":"Method 'map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def map(self, f: Callable[[T], U]) -> ProgramProtocol[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":449,"severity":"info","message":"Method 'flat_map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flat_map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flat_map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flat_map(self, f: Callable[[T], ProgramProtocol[U]]) -> ProgramProtocol[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":453,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":470,"severity":"warning","message":"Variable annotation 'auto_unwrap_strategy' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[_AutoUnwrapStrategy]' or '_AutoUnwrapStrategy | None', use 'Maybe[_AutoUnwrapStrategy]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"auto_unwrap_strategy: _AutoUnwrapStrategy | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":471,"severity":"warning","message":"Variable annotation 'execution_kernel' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[Callable[T, Generator[T, Any, T]]]' or 'Callable[T, Generator[T, Any, T]] | None', use 'Maybe[Callable[T, Generator[T, Any, T]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"execution_kernel: Callable[..., Generator[Effect | Program, Any, T]] | None = None"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":473,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":494,"severity":"info","message":"Function 'generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def generator() -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":582,"severity":"warning","message":"Function parameter 'create_derived (param 'args')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[tuple]' or 'tuple | None', use 'Maybe[tuple]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def create_derived("},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":582,"severity":"warning","message":"Function parameter 'create_derived (param 'kwargs')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, Any]]' or 'dict[str, Any] | None', use 'Maybe[dict[str, Any]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def create_derived("},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":602,"severity":"warning","message":"Function 'map' shadows Python built-in 'map'. Use a more descriptive name like 'map_impl' or 'create_map'.","source_line":"def map(self, f: Callable[[T], U]) -> KleisliProgramCall[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":602,"severity":"info","message":"Method 'map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def map(self, f: Callable[[T], U]) -> KleisliProgramCall[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":605,"severity":"info","message":"Function 'mapped_gen' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def mapped_gen(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def mapped_gen(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def mapped_gen(*_args: Any, **_kwargs: Any) -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":611,"severity":"info","message":"Method 'flat_map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flat_map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flat_map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flat_map(self, f: Callable[[T], ProgramProtocol[U]]) -> KleisliProgramCall[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":614,"severity":"info","message":"Function 'flatmapped_gen' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flatmapped_gen(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flatmapped_gen(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flatmapped_gen(*_args: Any, **_kwargs: Any) -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF020","file_path":"doeff/program.py","line":628,"severity":"warning","message":"Program variable 'base_program' uses deprecated '_program' suffix.\n\nNaming convention: Program type variables should be named with 'p_' prefix instead of '_program' suffix for consistency and brevity.\n\nFix: Rename the variable:\n  # Before\n  base_program: Program = ...\n  \n  # After\n  p_base: Program = ...","source_line":"base_program: Program[T]"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":631,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":634,"severity":"info","message":"Function 'generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def generator() -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":659,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF021","file_path":"doeff/program.py","line":669,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = [\"GeneratorProgram\", \"KleisliProgramCall\", \"Program\", \"ProgramProtocol\"]"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":35,"severity":"warning","message":"Async function 'test_recover_with_fallback_value' is missing a return type annotation.","source_line":"async def test_recover_with_fallback_value():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":61,"severity":"warning","message":"Async function 'test_recover_with_fallback_program' is missing a return type annotation.","source_line":"async def test_recover_with_fallback_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":89,"severity":"warning","message":"Async function 'test_recover_on_success' is missing a return type annotation.","source_line":"async def test_recover_on_success():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":114,"severity":"warning","message":"Async function 'test_retry_success_on_second_attempt' is missing a return type annotation.","source_line":"async def test_retry_success_on_second_attempt():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":149,"severity":"warning","message":"Async function 'test_retry_max_attempts_exceeded' is missing a return type annotation.","source_line":"async def test_retry_max_attempts_exceeded():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":174,"severity":"warning","message":"Async function 'test_retry_with_delay' is missing a return type annotation.","source_line":"async def test_retry_with_delay():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":221,"severity":"warning","message":"Async function 'test_retry_with_delay_strategy' is missing a return type annotation.","source_line":"async def test_retry_with_delay_strategy(monkeypatch):"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":226,"severity":"warning","message":"Async function 'fake_sleep' is missing a return type annotation.","source_line":"async def fake_sleep(duration: float):"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":226,"severity":"info","message":"Async function 'fake_sleep' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  async def fake_sleep(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  async def fake_sleep(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"async def fake_sleep(duration: float):"},{"rule_id":"DOEFF013","file_path":"tests/test_error_handling_effects.py","line":233,"severity":"warning","message":"Function parameter 'delay_strategy (param 'error')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[Exception]' or 'Exception | None', use 'Maybe[Exception]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def delay_strategy(attempt: int, error: Exception | None) -> float:"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":233,"severity":"info","message":"Function 'delay_strategy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def delay_strategy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def delay_strategy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def delay_strategy(attempt: int, error: Exception | None) -> float:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":266,"severity":"warning","message":"Async function 'test_nested_error_handling' is missing a return type annotation.","source_line":"async def test_nested_error_handling():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":294,"severity":"warning","message":"Async function 'test_catch_vs_recover' is missing a return type annotation.","source_line":"async def test_catch_vs_recover():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":331,"severity":"warning","message":"Async function 'test_catch_handler_logs_are_accumulated' is missing a return type annotation.","source_line":"async def test_catch_handler_logs_are_accumulated():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":359,"severity":"warning","message":"Async function 'test_catch_handler_logs_with_listen' is missing a return type annotation.","source_line":"async def test_catch_handler_logs_with_listen():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":389,"severity":"warning","message":"Async function 'test_catch_handler_fail_propagates_error_logs' is missing a return type annotation.","source_line":"async def test_catch_handler_fail_propagates_error_logs():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":423,"severity":"warning","message":"Async function 'test_catch_within_local_propagates_logs' is missing a return type annotation.","source_line":"async def test_catch_within_local_propagates_logs():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":457,"severity":"warning","message":"Async function 'test_retry_of_catch_preserves_attempt_logs' is missing a return type annotation.","source_line":"async def test_retry_of_catch_preserves_attempt_logs():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":501,"severity":"warning","message":"Async function 'test_why_try_except_doesnt_work' is missing a return type annotation.","source_line":"async def test_why_try_except_doesnt_work():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":536,"severity":"warning","message":"Async function 'test_recover_with_io_effect' is missing a return type annotation.","source_line":"async def test_recover_with_io_effect():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":542,"severity":"warning","message":"Function 'failing_io' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def failing_io():"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":542,"severity":"info","message":"Function 'failing_io' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def failing_io(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def failing_io(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def failing_io():"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":652,"severity":"info","message":"Function 'finalizer_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def finalizer_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def finalizer_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def finalizer_callable() -> None:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":700,"severity":"warning","message":"Async function 'test_native_try_except_catches_effect_error' is missing a return type annotation.","source_line":"async def test_native_try_except_catches_effect_error():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":705,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":705,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":705,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":719,"severity":"warning","message":"Async function 'test_native_try_except_catches_subprogram_error' is missing a return type annotation.","source_line":"async def test_native_try_except_catches_subprogram_error():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":729,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":729,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":729,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":743,"severity":"warning","message":"Async function 'test_nested_try_except' is missing a return type annotation.","source_line":"async def test_nested_try_except():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":748,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":748,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":748,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":765,"severity":"warning","message":"Async function 'test_try_finally_executes_on_exception' is missing a return type annotation.","source_line":"async def test_try_finally_executes_on_exception():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":772,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":772,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":772,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":789,"severity":"warning","message":"Async function 'test_uncaught_exception_becomes_err' is missing a return type annotation.","source_line":"async def test_uncaught_exception_becomes_err():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":794,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":794,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":794,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":810,"severity":"warning","message":"Async function 'test_exception_reraise' is missing a return type annotation.","source_line":"async def test_exception_reraise():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":815,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":815,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":815,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":830,"severity":"warning","message":"Async function 'test_safe_catch_recover_still_work' is missing a return type annotation.","source_line":"async def test_safe_catch_recover_still_work():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":842,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":842,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":842,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":858,"severity":"warning","message":"Async function 'test_try_except_with_multiple_yields' is missing a return type annotation.","source_line":"async def test_try_except_with_multiple_yields():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":864,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":864,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":864,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":884,"severity":"warning","message":"Async function 'test_try_except_with_state_effects' is missing a return type annotation.","source_line":"async def test_try_except_with_state_effects():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":891,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":891,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":891,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":907,"severity":"warning","message":"Async function 'test_try_except_with_log_effects' is missing a return type annotation.","source_line":"async def test_try_except_with_log_effects():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":914,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":914,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":914,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":933,"severity":"warning","message":"Async function 'test_try_except_with_io_effect' is missing a return type annotation.","source_line":"async def test_try_except_with_io_effect():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":941,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":941,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":938,"severity":"info","message":"Function 'failing_io' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def failing_io(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def failing_io(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def failing_io() -> None:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":941,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":955,"severity":"warning","message":"Async function 'test_try_except_with_nested_subprograms' is missing a return type annotation.","source_line":"async def test_try_except_with_nested_subprograms():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":975,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":975,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":975,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":989,"severity":"warning","message":"Async function 'test_try_except_with_recover_fallback' is missing a return type annotation.","source_line":"async def test_try_except_with_recover_fallback():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1001,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1001,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1001,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1023,"severity":"warning","message":"Async function 'test_try_except_inside_catch_handler' is missing a return type annotation.","source_line":"async def test_try_except_inside_catch_handler():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1028,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1028,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1028,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1051,"severity":"warning","message":"Async function 'test_try_except_with_finally_and_effects' is missing a return type annotation.","source_line":"async def test_try_except_with_finally_and_effects():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1058,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1058,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1058,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1078,"severity":"warning","message":"Async function 'test_try_except_preserves_context' is missing a return type annotation.","source_line":"async def test_try_except_preserves_context():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1085,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1085,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1085,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1103,"severity":"warning","message":"Async function 'test_multiple_try_except_blocks' is missing a return type annotation.","source_line":"async def test_multiple_try_except_blocks():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1110,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1115,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1120,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1110,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1115,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1120,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1110,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1115,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1120,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1135,"severity":"warning","message":"Async function 'test_try_except_with_safe_effect' is missing a return type annotation.","source_line":"async def test_try_except_with_safe_effect():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1145,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1145,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1145,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF012","file_path":"tests/test_yield_program.py","line":252,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'results'. Replace `results = []; for x in items: results.append(expr)` with `results = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for _ in range(3):"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":113,"severity":"warning","message":"Async function 'test_basic_program_yield' is missing a return type annotation.","source_line":"async def test_basic_program_yield():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":139,"severity":"warning","message":"Async function 'test_deeply_nested_yields' is missing a return type annotation.","source_line":"async def test_deeply_nested_yields():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":157,"severity":"warning","message":"Async function 'test_mixed_yields' is missing a return type annotation.","source_line":"async def test_mixed_yields():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":188,"severity":"warning","message":"Async function 'test_program_yield_with_error' is missing a return type annotation.","source_line":"async def test_program_yield_with_error():"},{"rule_id":"DOEFF014","file_path":"tests/test_yield_program.py","line":198,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_yield_program.py","line":198,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_yield_program.py","line":198,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":234,"severity":"warning","message":"Async function 'test_state_threading_through_programs' is missing a return type annotation.","source_line":"async def test_state_threading_through_programs():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":271,"severity":"warning","message":"Async function 'main' is missing a return type annotation.","source_line":"async def main():"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":20,"severity":"warning","message":"Async function 'test_fail_effect_with_creation_trace' is missing a return type annotation.","source_line":"async def test_fail_effect_with_creation_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":31,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":31,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":63,"severity":"warning","message":"Async function 'test_ask_effect_missing_key_with_trace' is missing a return type annotation.","source_line":"async def test_ask_effect_missing_key_with_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":74,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":74,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":103,"severity":"warning","message":"Async function 'test_effect_creation_trace_disabled' is missing a return type annotation.","source_line":"async def test_effect_creation_trace_disabled():"},{"rule_id":"DOEFF022","file_path":"tests/test_effect_creation_trace.py","line":112,"severity":"info","message":"Function 'simple_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def simple_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def simple_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def simple_program() -> EffectGenerator[str]:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":132,"severity":"warning","message":"Async function 'test_nested_program_creation_trace' is missing a return type annotation.","source_line":"async def test_nested_program_creation_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":142,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":142,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":176,"severity":"warning","message":"Async function 'test_effect_creation_context_structure' is missing a return type annotation.","source_line":"async def test_effect_creation_context_structure():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":186,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":186,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"tests/test_effect_creation_trace.py","line":187,"severity":"info","message":"Function 'program_with_effect' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def program_with_effect(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def program_with_effect(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def program_with_effect() -> EffectGenerator[str]:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":225,"severity":"warning","message":"Async function 'test_display_with_creation_trace' is missing a return type annotation.","source_line":"async def test_display_with_creation_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":243,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":243,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":295,"severity":"warning","message":"Async function 'test_nested_effect_error_chain' is missing a return type annotation.","source_line":"async def test_nested_effect_error_chain():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765070495,"datetime":"2025-12-07T01:21:35Z","files_scanned":6,"total_violations":369,"error_count":0,"warning_count":308,"info_count":61,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":623,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'tasks'. Replace `tasks = []; for x in items: tasks.append(expr)` with `tasks = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for prog in normalized_programs:"},{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":642,"severity":"warning","message":"Consider refactoring: 'results' is initialized as empty list and populated via for-loop with 4 statements. Extract the loop body into a named function and use list comprehension: `results = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for sub_result in sub_results:"},{"rule_id":"DOEFF012","file_path":"doeff/interpreter.py","line":651,"severity":"warning","message":"Consider refactoring: 'gather_inputs' is initialized as empty list and populated via for-loop with 4 statements. Extract the loop body into a named function and use list comprehension: `gather_inputs = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for sub_ctx in sub_contexts:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":79,"severity":"info","message":"Function '_effect_is' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _effect_is(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _effect_is(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _effect_is(effect: Effect, cls) -> bool:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":92,"severity":"info","message":"Function 'force_eval' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def force_eval(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def force_eval(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def force_eval(prog: Program[T]) -> Program[T]:"},{"rule_id":"DOEFF009","file_path":"doeff/interpreter.py","line":99,"severity":"warning","message":"Function 'forced_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def forced_generator():"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":99,"severity":"info","message":"Function 'forced_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def forced_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def forced_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def forced_generator():"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":106,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":116,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":122,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":127,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":146,"severity":"warning","message":"Function parameter '__init__ (param 'custom_handlers')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, Any]]' or 'dict[str, Any] | None', use 'Maybe[dict[str, Any]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def __init__("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":146,"severity":"warning","message":"Function parameter '__init__ (param 'max_log_entries')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def __init__("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":214,"severity":"warning","message":"Function parameter 'run (param 'context')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[ExecutionContext]' or 'ExecutionContext | None', use 'Maybe[ExecutionContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def run("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":214,"severity":"info","message":"Method 'run' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def run(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def run(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def run("},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":232,"severity":"warning","message":"Function parameter 'run_async (param 'context')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[ExecutionContext]' or 'ExecutionContext | None', use 'Maybe[ExecutionContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"async def run_async("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":232,"severity":"info","message":"Async method 'run_async' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  async def run_async(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  async def run_async(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"async def run_async("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":261,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":300,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":305,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":322,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":341,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":355,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":370,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":384,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":389,"severity":"warning","message":"Variable annotation 'effect_type' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"effect_type: str | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":390,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":604,"severity":"info","message":"Function '_enqueue_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _enqueue_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _enqueue_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _enqueue_program(prog_like: Any) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/interpreter.py","line":640,"severity":"warning","message":"Variable annotation 'error_to_raise' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"error_to_raise: BaseException | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":671,"severity":"info","message":"Function '_build_intercept_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _build_intercept_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _build_intercept_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _build_intercept_program("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":694,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":684,"severity":"info","message":"Function '_intercept_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_generator("},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":694,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":701,"severity":"info","message":"Function '_forward_exception' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _forward_exception(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _forward_exception(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _forward_exception(e: BaseException) -> bool | T:  # noqa: DOEFF014"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":704,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":713,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":733,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":743,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":751,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":761,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":767,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/interpreter.py","line":777,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":783,"severity":"info","message":"Function '_compose_intercept_transforms' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _compose_intercept_transforms(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _compose_intercept_transforms(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _compose_intercept_transforms("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":791,"severity":"info","message":"Function 'combined' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def combined(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def combined(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def combined(effect: EffectBase) -> Program[EffectBase]:"},{"rule_id":"DOEFF020","file_path":"doeff/interpreter.py","line":792,"severity":"info","message":"Program variable 'program' should use 'p_' prefix.\n\nNaming convention: Program type variables should be named with 'p_' prefix for consistency and brevity.\n\nFix: Rename the variable:\n  # Before\n  program: Program = ...\n  \n  # After\n  p_program: Program = ...","source_line":"program: Program[EffectBase] = Program.pure(effect)"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":800,"severity":"info","message":"Function '_lift_intercept_transform' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _lift_intercept_transform(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _lift_intercept_transform(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _lift_intercept_transform("},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":806,"severity":"info","message":"Function 'lifted' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lifted(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lifted(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lifted(effect: EffectBase) -> Program:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":823,"severity":"info","message":"Function '_ensure_effect_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _ensure_effect_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _ensure_effect_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _ensure_effect_program(value: Any) -> Program:"},{"rule_id":"DOEFF022","file_path":"doeff/interpreter.py","line":835,"severity":"info","message":"Function '_program_to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _program_to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _program_to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _program_to_generator("},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":66,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":66,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/do.py","line":28,"severity":"info","message":"Function 'generator_wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def generator_wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def generator_wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def generator_wrapper("},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":36,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":42,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":48,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":53,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/do.py","line":66,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/do.py","line":80,"severity":"info","message":"Function 'do' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def do(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def do(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def do("},{"rule_id":"DOEFF012","file_path":"doeff/program.py","line":499,"severity":"warning","message":"Consider refactoring: 'program_args' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `program_args = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for index, arg in enumerate(args_tuple):"},{"rule_id":"DOEFF012","file_path":"doeff/program.py","line":499,"severity":"warning","message":"Consider refactoring: 'program_indices' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `program_indices = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for index, arg in enumerate(args_tuple):"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":44,"severity":"warning","message":"Variable annotation 'variable' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"self.var_positional: bool | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":46,"severity":"warning","message":"Variable annotation 'variable' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"self.var_keyword: bool | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":48,"severity":"info","message":"Method 'should_unwrap_positional' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def should_unwrap_positional(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def should_unwrap_positional(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def should_unwrap_positional(self, index: int) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":55,"severity":"info","message":"Method 'should_unwrap_keyword' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def should_unwrap_keyword(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def should_unwrap_keyword(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def should_unwrap_keyword(self, name: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":63,"severity":"info","message":"Function '_string_annotation_is_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _string_annotation_is_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _string_annotation_is_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _string_annotation_is_program(annotation_text: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":89,"severity":"info","message":"Function '_string_annotation_is_effect' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _string_annotation_is_effect(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _string_annotation_is_effect(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _string_annotation_is_effect(annotation_text: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":117,"severity":"info","message":"Function '_annotation_is_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _annotation_is_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _annotation_is_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _annotation_is_program(annotation: Any) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":143,"severity":"info","message":"Function '_annotation_is_effect' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _annotation_is_effect(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _annotation_is_effect(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _annotation_is_effect(annotation: Any) -> bool:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":171,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":168,"severity":"info","message":"Function '_safe_get_type_hints' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _safe_get_type_hints(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _safe_get_type_hints(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _safe_get_type_hints(target: Any) -> dict[str, Any]:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":171,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":178,"severity":"warning","message":"Function return type '_safe_signature' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[inspect.Signature]' or 'inspect.Signature | None', use 'Maybe[inspect.Signature]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _safe_signature(target: Any) -> inspect.Signature | None:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":179,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":178,"severity":"info","message":"Function '_safe_signature' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _safe_signature(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _safe_signature(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _safe_signature(target: Any) -> inspect.Signature | None:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":179,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":185,"severity":"info","message":"Function '_build_auto_unwrap_strategy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _build_auto_unwrap_strategy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _build_auto_unwrap_strategy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _build_auto_unwrap_strategy(kleisli: Any) -> _AutoUnwrapStrategy:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":220,"severity":"warning","message":"Method '__class_getitem__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __class_getitem__(cls, item):"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":230,"severity":"info","message":"Function 'mapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def mapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def mapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def mapper(value: Any) -> Any:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":231,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":248,"severity":"info","message":"Function 'invoke_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def invoke_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def invoke_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def invoke_callable(func: Any) -> Program[Any]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":256,"severity":"info","message":"Function 'gather_inputs' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def gather_inputs(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def gather_inputs(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def gather_inputs() -> Generator[Effect | Program, Any, tuple[list[Any], dict[str, Any]]]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":261,"severity":"info","message":"Function 'call_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def call_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def call_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def call_program() -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":272,"severity":"warning","message":"Function 'map' shadows Python built-in 'map'. Use a more descriptive name like 'map_impl' or 'create_map'.","source_line":"def map(self, f: Callable[[T], U]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":272,"severity":"info","message":"Method 'map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def map(self, f: Callable[[T], U]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":278,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":284,"severity":"info","message":"Method 'flat_map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flat_map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flat_map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flat_map(self, f: Callable[[T], Program[U]]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":290,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":303,"severity":"info","message":"Method 'and_then_k' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def and_then_k(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def and_then_k(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def and_then_k(self, binder: Callable[[T], Program[U]]) -> Program[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":308,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":341,"severity":"warning","message":"Function 'first_success_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def first_success_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":341,"severity":"info","message":"Function 'first_success_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def first_success_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def first_success_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def first_success_generator():"},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":355,"severity":"warning","message":"Function 'first_some_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def first_some_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":355,"severity":"info","message":"Function 'first_some_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def first_some_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def first_some_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def first_some_generator():"},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":378,"severity":"warning","message":"Function 'sequence_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def sequence_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":378,"severity":"info","message":"Function 'sequence_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def sequence_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def sequence_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def sequence_generator():"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":394,"severity":"warning","message":"Function 'list' shadows Python built-in 'list'. Use a more descriptive name like 'list_impl' or 'create_list'.","source_line":"def list(*values: Iterable[Program[U] | U]) -> Program[list[U]]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":399,"severity":"warning","message":"Function 'tuple' shadows Python built-in 'tuple'. Use a more descriptive name like 'tuple_impl' or 'create_tuple'.","source_line":"def tuple(*values: Iterable[Program[U] | U]) -> Program[tuple[U, ...]]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":403,"severity":"warning","message":"Function 'set' shadows Python built-in 'set'. Use a more descriptive name like 'set_impl' or 'create_set'.","source_line":"def set(*values: Iterable[Program[U] | U]) -> Program[set[U]]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":407,"severity":"warning","message":"Function 'dict' shadows Python built-in 'dict'. Use a more descriptive name like 'dict_impl' or 'create_dict'.","source_line":"def dict("},{"rule_id":"DOEFF009","file_path":"doeff/program.py","line":415,"severity":"warning","message":"Function 'dict_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def dict_generator():"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":415,"severity":"info","message":"Function 'dict_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def dict_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def dict_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def dict_generator():"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":432,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[Any]' or 'Any | None', use 'Maybe[Any]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: Any | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":434,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":445,"severity":"warning","message":"Function 'map' shadows Python built-in 'map'. Use a more descriptive name like 'map_impl' or 'create_map'.","source_line":"def map(self, f: Callable[[T], U]) -> ProgramProtocol[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":445,"severity":"info","message":"Method 'map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def map(self, f: Callable[[T], U]) -> ProgramProtocol[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":449,"severity":"info","message":"Method 'flat_map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flat_map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flat_map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flat_map(self, f: Callable[[T], ProgramProtocol[U]]) -> ProgramProtocol[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":453,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":470,"severity":"warning","message":"Variable annotation 'auto_unwrap_strategy' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[_AutoUnwrapStrategy]' or '_AutoUnwrapStrategy | None', use 'Maybe[_AutoUnwrapStrategy]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"auto_unwrap_strategy: _AutoUnwrapStrategy | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":471,"severity":"warning","message":"Variable annotation 'execution_kernel' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[Callable[T, Generator[T, Any, T]]]' or 'Callable[T, Generator[T, Any, T]] | None', use 'Maybe[Callable[T, Generator[T, Any, T]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"execution_kernel: Callable[..., Generator[Effect | Program, Any, T]] | None = None"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":473,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":494,"severity":"info","message":"Function 'generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def generator() -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":535,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":541,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":547,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/program.py","line":552,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":582,"severity":"warning","message":"Function parameter 'create_derived (param 'args')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[tuple]' or 'tuple | None', use 'Maybe[tuple]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def create_derived("},{"rule_id":"DOEFF013","file_path":"doeff/program.py","line":582,"severity":"warning","message":"Function parameter 'create_derived (param 'kwargs')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, Any]]' or 'dict[str, Any] | None', use 'Maybe[dict[str, Any]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def create_derived("},{"rule_id":"DOEFF001","file_path":"doeff/program.py","line":602,"severity":"warning","message":"Function 'map' shadows Python built-in 'map'. Use a more descriptive name like 'map_impl' or 'create_map'.","source_line":"def map(self, f: Callable[[T], U]) -> KleisliProgramCall[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":602,"severity":"info","message":"Method 'map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def map(self, f: Callable[[T], U]) -> KleisliProgramCall[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":605,"severity":"info","message":"Function 'mapped_gen' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def mapped_gen(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def mapped_gen(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def mapped_gen(*_args: Any, **_kwargs: Any) -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":611,"severity":"info","message":"Method 'flat_map' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flat_map(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flat_map(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flat_map(self, f: Callable[[T], ProgramProtocol[U]]) -> KleisliProgramCall[U]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":614,"severity":"info","message":"Function 'flatmapped_gen' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def flatmapped_gen(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def flatmapped_gen(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def flatmapped_gen(*_args: Any, **_kwargs: Any) -> Generator[Effect | Program, Any, U]:"},{"rule_id":"DOEFF020","file_path":"doeff/program.py","line":628,"severity":"warning","message":"Program variable 'base_program' uses deprecated '_program' suffix.\n\nNaming convention: Program type variables should be named with 'p_' prefix instead of '_program' suffix for consistency and brevity.\n\nFix: Rename the variable:\n  # Before\n  base_program: Program = ...\n  \n  # After\n  p_base: Program = ...","source_line":"base_program: Program[T]"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":631,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":634,"severity":"info","message":"Function 'generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def generator() -> Generator[Effect | Program, Any, T]:"},{"rule_id":"DOEFF022","file_path":"doeff/program.py","line":659,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":35,"severity":"warning","message":"Async function 'test_recover_with_fallback_value' is missing a return type annotation.","source_line":"async def test_recover_with_fallback_value():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":61,"severity":"warning","message":"Async function 'test_recover_with_fallback_program' is missing a return type annotation.","source_line":"async def test_recover_with_fallback_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":89,"severity":"warning","message":"Async function 'test_recover_on_success' is missing a return type annotation.","source_line":"async def test_recover_on_success():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":114,"severity":"warning","message":"Async function 'test_retry_success_on_second_attempt' is missing a return type annotation.","source_line":"async def test_retry_success_on_second_attempt():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":149,"severity":"warning","message":"Async function 'test_retry_max_attempts_exceeded' is missing a return type annotation.","source_line":"async def test_retry_max_attempts_exceeded():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":174,"severity":"warning","message":"Async function 'test_retry_with_delay' is missing a return type annotation.","source_line":"async def test_retry_with_delay():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":221,"severity":"warning","message":"Async function 'test_retry_with_delay_strategy' is missing a return type annotation.","source_line":"async def test_retry_with_delay_strategy(monkeypatch):"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":226,"severity":"warning","message":"Async function 'fake_sleep' is missing a return type annotation.","source_line":"async def fake_sleep(duration: float):"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":226,"severity":"info","message":"Async function 'fake_sleep' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  async def fake_sleep(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  async def fake_sleep(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"async def fake_sleep(duration: float):"},{"rule_id":"DOEFF013","file_path":"tests/test_error_handling_effects.py","line":233,"severity":"warning","message":"Function parameter 'delay_strategy (param 'error')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[Exception]' or 'Exception | None', use 'Maybe[Exception]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def delay_strategy(attempt: int, error: Exception | None) -> float:"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":233,"severity":"info","message":"Function 'delay_strategy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def delay_strategy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def delay_strategy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def delay_strategy(attempt: int, error: Exception | None) -> float:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":266,"severity":"warning","message":"Async function 'test_nested_error_handling' is missing a return type annotation.","source_line":"async def test_nested_error_handling():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":294,"severity":"warning","message":"Async function 'test_catch_vs_recover' is missing a return type annotation.","source_line":"async def test_catch_vs_recover():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":331,"severity":"warning","message":"Async function 'test_catch_handler_logs_are_accumulated' is missing a return type annotation.","source_line":"async def test_catch_handler_logs_are_accumulated():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":359,"severity":"warning","message":"Async function 'test_catch_handler_logs_with_listen' is missing a return type annotation.","source_line":"async def test_catch_handler_logs_with_listen():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":389,"severity":"warning","message":"Async function 'test_catch_handler_fail_propagates_error_logs' is missing a return type annotation.","source_line":"async def test_catch_handler_fail_propagates_error_logs():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":423,"severity":"warning","message":"Async function 'test_catch_within_local_propagates_logs' is missing a return type annotation.","source_line":"async def test_catch_within_local_propagates_logs():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":457,"severity":"warning","message":"Async function 'test_retry_of_catch_preserves_attempt_logs' is missing a return type annotation.","source_line":"async def test_retry_of_catch_preserves_attempt_logs():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":501,"severity":"warning","message":"Async function 'test_why_try_except_doesnt_work' is missing a return type annotation.","source_line":"async def test_why_try_except_doesnt_work():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":536,"severity":"warning","message":"Async function 'test_recover_with_io_effect' is missing a return type annotation.","source_line":"async def test_recover_with_io_effect():"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":542,"severity":"warning","message":"Function 'failing_io' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def failing_io():"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":542,"severity":"info","message":"Function 'failing_io' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def failing_io(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def failing_io(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def failing_io():"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":652,"severity":"info","message":"Function 'finalizer_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def finalizer_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def finalizer_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def finalizer_callable() -> None:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":700,"severity":"warning","message":"Async function 'test_native_try_except_catches_effect_error' is missing a return type annotation.","source_line":"async def test_native_try_except_catches_effect_error():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":705,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":705,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":705,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":719,"severity":"warning","message":"Async function 'test_native_try_except_catches_subprogram_error' is missing a return type annotation.","source_line":"async def test_native_try_except_catches_subprogram_error():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":729,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":729,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":729,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":743,"severity":"warning","message":"Async function 'test_nested_try_except' is missing a return type annotation.","source_line":"async def test_nested_try_except():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":748,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":748,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":748,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":749,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":765,"severity":"warning","message":"Async function 'test_try_finally_executes_on_exception' is missing a return type annotation.","source_line":"async def test_try_finally_executes_on_exception():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":772,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":772,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":772,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":789,"severity":"warning","message":"Async function 'test_uncaught_exception_becomes_err' is missing a return type annotation.","source_line":"async def test_uncaught_exception_becomes_err():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":794,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":794,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":794,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":810,"severity":"warning","message":"Async function 'test_exception_reraise' is missing a return type annotation.","source_line":"async def test_exception_reraise():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":815,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":815,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":815,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":830,"severity":"warning","message":"Async function 'test_safe_catch_recover_still_work' is missing a return type annotation.","source_line":"async def test_safe_catch_recover_still_work():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":842,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":842,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":842,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":858,"severity":"warning","message":"Async function 'test_try_except_with_multiple_yields' is missing a return type annotation.","source_line":"async def test_try_except_with_multiple_yields():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":864,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":864,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":864,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":884,"severity":"warning","message":"Async function 'test_try_except_with_state_effects' is missing a return type annotation.","source_line":"async def test_try_except_with_state_effects():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":891,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":891,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":891,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":907,"severity":"warning","message":"Async function 'test_try_except_with_log_effects' is missing a return type annotation.","source_line":"async def test_try_except_with_log_effects():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":914,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":914,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":914,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":933,"severity":"warning","message":"Async function 'test_try_except_with_io_effect' is missing a return type annotation.","source_line":"async def test_try_except_with_io_effect():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":941,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":941,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"tests/test_error_handling_effects.py","line":938,"severity":"info","message":"Function 'failing_io' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def failing_io(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def failing_io(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def failing_io() -> None:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":941,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":955,"severity":"warning","message":"Async function 'test_try_except_with_nested_subprograms' is missing a return type annotation.","source_line":"async def test_try_except_with_nested_subprograms():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":975,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":975,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":975,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":989,"severity":"warning","message":"Async function 'test_try_except_with_recover_fallback' is missing a return type annotation.","source_line":"async def test_try_except_with_recover_fallback():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1001,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1001,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1001,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1023,"severity":"warning","message":"Async function 'test_try_except_inside_catch_handler' is missing a return type annotation.","source_line":"async def test_try_except_inside_catch_handler():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1028,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1028,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1028,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1051,"severity":"warning","message":"Async function 'test_try_except_with_finally_and_effects' is missing a return type annotation.","source_line":"async def test_try_except_with_finally_and_effects():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1058,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1058,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1058,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1078,"severity":"warning","message":"Async function 'test_try_except_preserves_context' is missing a return type annotation.","source_line":"async def test_try_except_preserves_context():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1085,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1085,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1085,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1103,"severity":"warning","message":"Async function 'test_multiple_try_except_blocks' is missing a return type annotation.","source_line":"async def test_multiple_try_except_blocks():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1110,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1115,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1120,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1110,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1115,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1120,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1110,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1115,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1120,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_error_handling_effects.py","line":1135,"severity":"warning","message":"Async function 'test_try_except_with_safe_effect' is missing a return type annotation.","source_line":"async def test_try_except_with_safe_effect():"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1145,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1145,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_error_handling_effects.py","line":1145,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF012","file_path":"tests/test_yield_program.py","line":252,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'results'. Replace `results = []; for x in items: results.append(expr)` with `results = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for _ in range(3):"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":113,"severity":"warning","message":"Async function 'test_basic_program_yield' is missing a return type annotation.","source_line":"async def test_basic_program_yield():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":139,"severity":"warning","message":"Async function 'test_deeply_nested_yields' is missing a return type annotation.","source_line":"async def test_deeply_nested_yields():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":157,"severity":"warning","message":"Async function 'test_mixed_yields' is missing a return type annotation.","source_line":"async def test_mixed_yields():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":188,"severity":"warning","message":"Async function 'test_program_yield_with_error' is missing a return type annotation.","source_line":"async def test_program_yield_with_error():"},{"rule_id":"DOEFF014","file_path":"tests/test_yield_program.py","line":198,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_yield_program.py","line":198,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_yield_program.py","line":198,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":234,"severity":"warning","message":"Async function 'test_state_threading_through_programs' is missing a return type annotation.","source_line":"async def test_state_threading_through_programs():"},{"rule_id":"DOEFF009","file_path":"tests/test_yield_program.py","line":271,"severity":"warning","message":"Async function 'main' is missing a return type annotation.","source_line":"async def main():"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":20,"severity":"warning","message":"Async function 'test_fail_effect_with_creation_trace' is missing a return type annotation.","source_line":"async def test_fail_effect_with_creation_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":31,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":31,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":63,"severity":"warning","message":"Async function 'test_ask_effect_missing_key_with_trace' is missing a return type annotation.","source_line":"async def test_ask_effect_missing_key_with_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":74,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":74,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":103,"severity":"warning","message":"Async function 'test_effect_creation_trace_disabled' is missing a return type annotation.","source_line":"async def test_effect_creation_trace_disabled():"},{"rule_id":"DOEFF022","file_path":"tests/test_effect_creation_trace.py","line":112,"severity":"info","message":"Function 'simple_program' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def simple_program(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def simple_program(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def simple_program() -> EffectGenerator[str]:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":132,"severity":"warning","message":"Async function 'test_nested_program_creation_trace' is missing a return type annotation.","source_line":"async def test_nested_program_creation_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":142,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":142,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":176,"severity":"warning","message":"Async function 'test_effect_creation_context_structure' is missing a return type annotation.","source_line":"async def test_effect_creation_context_structure():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":186,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":186,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"tests/test_effect_creation_trace.py","line":187,"severity":"info","message":"Function 'program_with_effect' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def program_with_effect(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def program_with_effect(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def program_with_effect() -> EffectGenerator[str]:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":225,"severity":"warning","message":"Async function 'test_display_with_creation_trace' is missing a return type annotation.","source_line":"async def test_display_with_creation_trace():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":243,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":243,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF009","file_path":"tests/test_effect_creation_trace.py","line":295,"severity":"warning","message":"Async function 'test_nested_effect_error_chain' is missing a return type annotation.","source_line":"async def test_nested_effect_error_chain():"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"tests/test_effect_creation_trace.py","line":311,"severity":"warning","message":"Avoid using try-except blocks. Use doeff's error handling effects instead: `Safe(program)` to get a Result object, `program.recover(fallback)` for fallback values, `program.first_success(alt1, alt2)` to try alternatives, or `Catch(program, handler)` to transform errors. Example: `result = yield Safe(risky_op())` then match on Ok/Err.","source_line":"try:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078169,"datetime":"2025-12-07T03:29:29Z","files_scanned":2,"total_violations":153,"error_count":4,"warning_count":77,"info_count":72,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":989,"severity":"error","message":"Function '_build_base_graph' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _build_base_graph("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1063,"severity":"error","message":"Function '_resolve_graph_style' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1248,"severity":"error","message":"Function 'keys_for' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"},{"rule_id":"DOEFF021","file_path":"doeff/_types_internal.py","line":1821,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = ["},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":26,"severity":"warning","message":"Method 'test_generator_program_to_generator_returns_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_generator_program_to_generator_returns_generator(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":29,"severity":"warning","message":"Function 'factory' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def factory():"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":29,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":44,"severity":"warning","message":"Method 'test_kleisli_program_call_to_generator_returns_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_kleisli_program_call_to_generator_returns_generator(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":48,"severity":"warning","message":"Function 'my_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def my_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":65,"severity":"warning","message":"Method 'test_intercepted_program_to_generator_returns_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_intercepted_program_to_generator_returns_generator(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":69,"severity":"warning","message":"Function 'my_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def my_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":147,"severity":"warning","message":"Method 'test_getattr_creates_projection_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_getattr_creates_projection_program(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":151,"severity":"warning","message":"Function 'my_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def my_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":182,"severity":"warning","message":"Method 'test_all_program_subclasses_have_to_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_all_program_subclasses_have_to_generator(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":200,"severity":"warning","message":"Method 'test_generator_program_factory_called_each_time' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_generator_program_factory_called_each_time(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":204,"severity":"warning","message":"Function 'factory' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def factory():"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":204,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":222,"severity":"warning","message":"Method 'test_kleisli_program_creates_fresh_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_kleisli_program_creates_fresh_generator(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":226,"severity":"warning","message":"Function 'my_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def my_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":237,"severity":"warning","message":"Method 'test_mapped_program_to_generator_returns_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_mapped_program_to_generator_returns_generator(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":241,"severity":"warning","message":"Function 'my_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def my_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":253,"severity":"warning","message":"Method 'test_flat_mapped_program_to_generator_returns_generator' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_flat_mapped_program_to_generator_returns_generator(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":257,"severity":"warning","message":"Function 'my_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def my_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":261,"severity":"warning","message":"Function 'next_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def next_program(x):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":276,"severity":"warning","message":"Method 'test_local_effect_with_generator_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_local_effect_with_generator_program(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":279,"severity":"warning","message":"Function 'factory' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def factory():"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":279,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":289,"severity":"warning","message":"Method 'test_local_effect_with_kleisli_program_call' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_local_effect_with_kleisli_program_call(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":293,"severity":"warning","message":"Function 'my_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def my_program():"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":302,"severity":"warning","message":"Method 'test_local_effect_with_effect' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_local_effect_with_effect(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":314,"severity":"warning","message":"Method 'test_program_base_to_generator_not_in_dict' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def test_program_base_to_generator_not_in_dict(self):"},{"rule_id":"DOEFF009","file_path":"tests/test_to_generator_consistency.py","line":349,"severity":"warning","message":"Function 'my_program' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def my_program():"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078420,"datetime":"2025-12-07T03:33:40Z","files_scanned":1,"total_violations":3,"error_count":0,"warning_count":0,"info_count":3,"violations":[{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":29,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":204,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":279,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078429,"datetime":"2025-12-07T03:33:49Z","files_scanned":1,"total_violations":125,"error_count":4,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":989,"severity":"error","message":"Function '_build_base_graph' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _build_base_graph("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1063,"severity":"error","message":"Function '_resolve_graph_style' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1248,"severity":"error","message":"Function 'keys_for' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"},{"rule_id":"DOEFF021","file_path":"doeff/_types_internal.py","line":1821,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = ["}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078436,"datetime":"2025-12-07T03:33:56Z","files_scanned":1,"total_violations":125,"error_count":4,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":989,"severity":"error","message":"Function '_build_base_graph' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _build_base_graph("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1063,"severity":"error","message":"Function '_resolve_graph_style' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1248,"severity":"error","message":"Function 'keys_for' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"},{"rule_id":"DOEFF021","file_path":"doeff/_types_internal.py","line":1821,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = ["}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078480,"datetime":"2025-12-07T03:34:40Z","files_scanned":2,"total_violations":128,"error_count":4,"warning_count":52,"info_count":72,"violations":[{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":29,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":204,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":279,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":989,"severity":"error","message":"Function '_build_base_graph' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _build_base_graph("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1063,"severity":"error","message":"Function '_resolve_graph_style' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1248,"severity":"error","message":"Function 'keys_for' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"},{"rule_id":"DOEFF021","file_path":"doeff/_types_internal.py","line":1821,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = ["}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078493,"datetime":"2025-12-07T03:34:53Z","files_scanned":1,"total_violations":125,"error_count":4,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":989,"severity":"error","message":"Function '_build_base_graph' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _build_base_graph("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1063,"severity":"error","message":"Function '_resolve_graph_style' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1248,"severity":"error","message":"Function 'keys_for' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"},{"rule_id":"DOEFF021","file_path":"doeff/_types_internal.py","line":1821,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = ["}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078497,"datetime":"2025-12-07T03:34:57Z","files_scanned":1,"total_violations":125,"error_count":4,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":989,"severity":"error","message":"Function '_build_base_graph' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _build_base_graph("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1063,"severity":"error","message":"Function '_resolve_graph_style' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1248,"severity":"error","message":"Function 'keys_for' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"},{"rule_id":"DOEFF021","file_path":"doeff/_types_internal.py","line":1821,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = ["}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078502,"datetime":"2025-12-07T03:35:02Z","files_scanned":1,"total_violations":125,"error_count":4,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":989,"severity":"error","message":"Function '_build_base_graph' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _build_base_graph("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1063,"severity":"error","message":"Function '_resolve_graph_style' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1248,"severity":"error","message":"Function 'keys_for' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"},{"rule_id":"DOEFF021","file_path":"doeff/_types_internal.py","line":1821,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = ["}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078510,"datetime":"2025-12-07T03:35:10Z","files_scanned":1,"total_violations":125,"error_count":4,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":989,"severity":"error","message":"Function '_build_base_graph' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _build_base_graph("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1063,"severity":"error","message":"Function '_resolve_graph_style' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF006","file_path":"doeff/_types_internal.py","line":1248,"severity":"error","message":"Function 'keys_for' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"},{"rule_id":"DOEFF021","file_path":"doeff/_types_internal.py","line":1821,"severity":"error","message":"'__all__' should not be used.\n\nPolicy: This project defaults to exporting everything from modules.\nUsing __all__ restricts exports and goes against the project convention.\n\nFix: Remove the __all__ declaration. If you need to limit exports for a\nspecific reason, add a comment explaining why and use # noqa: DOEFF021.","source_line":"__all__ = ["}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078596,"datetime":"2025-12-07T03:36:36Z","files_scanned":2,"total_violations":124,"error_count":0,"warning_count":52,"info_count":72,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":29,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":204,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":279,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078605,"datetime":"2025-12-07T03:36:45Z","files_scanned":1,"total_violations":121,"error_count":0,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078614,"datetime":"2025-12-07T03:36:54Z","files_scanned":1,"total_violations":121,"error_count":0,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078618,"datetime":"2025-12-07T03:36:58Z","files_scanned":1,"total_violations":121,"error_count":0,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078640,"datetime":"2025-12-07T03:37:20Z","files_scanned":1,"total_violations":121,"error_count":0,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078666,"datetime":"2025-12-07T03:37:46Z","files_scanned":1,"total_violations":121,"error_count":0,"warning_count":52,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF001","file_path":"doeff/_types_internal.py","line":260,"severity":"warning","message":"Function 'format' shadows Python built-in 'format'. Use a more descriptive name like 'format_impl' or 'create_format'.","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":488,"severity":"warning","message":"Method '__post_init__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __post_init__(self):"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":977,"severity":"warning","message":"Function '_import_phart_dependencies' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _import_phart_dependencies():"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1764,"severity":"warning","message":"Method '__iter__' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def __iter__(self):"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF009","file_path":"doeff/_types_internal.py","line":1810,"severity":"warning","message":"Function '_wrap_callable' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078720,"datetime":"2025-12-07T03:38:40Z","files_scanned":1,"total_violations":116,"error_count":0,"warning_count":47,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078728,"datetime":"2025-12-07T03:38:48Z","files_scanned":1,"total_violations":116,"error_count":0,"warning_count":47,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":912,"severity":"warning","message":"Function 'display' has flag argument 'verbose' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078818,"datetime":"2025-12-07T03:40:18Z","files_scanned":1,"total_violations":115,"error_count":0,"warning_count":46,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078825,"datetime":"2025-12-07T03:40:25Z","files_scanned":1,"total_violations":115,"error_count":0,"warning_count":46,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078846,"datetime":"2025-12-07T03:40:46Z","files_scanned":1,"total_violations":115,"error_count":0,"warning_count":46,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":170,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":220,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1208,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1486,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1744,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":86,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":86,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":120,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":124,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":128,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":142,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":166,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":243,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":262,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":287,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":313,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":319,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":330,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":341,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":373,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":397,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":397,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":411,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":427,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":427,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":437,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":445,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":454,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":454,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":474,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":475,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":517,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":519,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":524,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":524,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":532,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":543,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":543,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":550,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":591,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":627,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":640,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":661,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":662,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":678,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":679,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":687,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":700,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":708,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":708,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":708,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":716,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":724,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":980,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1022,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1081,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1137,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1156,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":824,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":846,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":857,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":914,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":940,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":930,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":930,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":930,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":980,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":980,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1019,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1022,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1022,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1065,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1081,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1081,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1081,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1091,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1091,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1137,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1137,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1156,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1156,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1183,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1203,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1203,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1247,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1250,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1261,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1264,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1274,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1277,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1285,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1290,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1354,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1361,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1384,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1399,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1498,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1515,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1532,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1548,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1588,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1613,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1632,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1664,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1704,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1727,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1771,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1799,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1812,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1818,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078860,"datetime":"2025-12-07T03:41:00Z","files_scanned":1,"total_violations":115,"error_count":0,"warning_count":46,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":170,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":220,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1208,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1486,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1744,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":86,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":86,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":120,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":124,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":128,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":142,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":166,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":243,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":262,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":287,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":313,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":319,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":330,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":341,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":373,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":397,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":397,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":411,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":427,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":427,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":437,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":445,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":454,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":454,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":474,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":475,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":517,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":519,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":524,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":524,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":532,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":543,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":543,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":550,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":591,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":627,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":640,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":661,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":662,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":678,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":679,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":687,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":700,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":708,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":708,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":708,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":716,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":724,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":980,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1022,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1081,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1137,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1156,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":824,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":846,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":857,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":914,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":940,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":930,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":930,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":930,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":980,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":980,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1019,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1022,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1022,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1065,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1081,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1081,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1081,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1091,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1091,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1137,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1137,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1156,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1156,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1183,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1203,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1203,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1247,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1250,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1261,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1264,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1274,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1277,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1285,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1290,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1354,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1361,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1384,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1399,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1498,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1515,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1532,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1548,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1588,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1613,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1632,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1664,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1704,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1727,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1771,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1799,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1812,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1818,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078879,"datetime":"2025-12-07T03:41:19Z","files_scanned":1,"total_violations":115,"error_count":0,"warning_count":46,"info_count":69,"violations":[{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":168,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'sanitized_stack'. Replace `sanitized_stack = []; for x in items: sanitized_stack.append(expr)` with `sanitized_stack = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in self.stack_trace:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":218,"severity":"warning","message":"Consider refactoring: 'sanitized' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `sanitized = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for line in lines:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1206,"severity":"warning","message":"Consider refactoring: 'records' is initialized as empty list and populated via for-loop with 14 statements. Extract the loop body into a named function and use list comprehension: `records = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for observation in observations:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1484,"severity":"warning","message":"Consider using list comprehension instead of append loop for 'frames'. Replace `frames = []; for x in items: frames.append(expr)` with `frames = [expr for x in items]`. If mutation is required (e.g., queue/stack, dynamic algorithm), add `# noqa: DOEFF012`","source_line":"for frame in raw_frames:"},{"rule_id":"DOEFF012","file_path":"doeff/_types_internal.py","line":1742,"severity":"warning","message":"Consider refactoring: 'collected' is initialized as empty list and populated via for-loop with 6 statements. Extract the loop body into a named function and use list comprehension: `collected = [process_item(x) for x in iterable]`. If this is intentional (e.g., queue/stack operations, complex algorithm), add `# noqa: DOEFF012`","source_line":"for section in sections:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078919,"datetime":"2025-12-07T03:41:59Z","files_scanned":1,"total_violations":110,"error_count":0,"warning_count":41,"info_count":69,"violations":[{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078925,"datetime":"2025-12-07T03:42:05Z","files_scanned":1,"total_violations":110,"error_count":0,"warning_count":41,"info_count":69,"violations":[{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078932,"datetime":"2025-12-07T03:42:12Z","files_scanned":1,"total_violations":110,"error_count":0,"warning_count":41,"info_count":69,"violations":[{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":938,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool = True,"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1017,"severity":"warning","message":"Function '_build_label_map' has flag argument 'include_ops' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"include_ops: bool,"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1257,"severity":"warning","message":"Dataclass 'RunResultDisplayContext' has flag attribute 'verbose' with type 'bool'. Store a protocol object or callable that encapsulates the varying behavior instead. Example: instead of 'use_cache: bool = True', use 'cache: CacheProtocol = DefaultCache()'.","source_line":"verbose: bool"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1382,"severity":"warning","message":"Function '_render_effect_entry' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":1397,"severity":"warning","message":"Function '_render_effect_creation_details' has flag argument 'is_primary' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"is_primary: bool,"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078959,"datetime":"2025-12-07T03:42:39Z","files_scanned":1,"total_violations":105,"error_count":0,"warning_count":36,"info_count":69,"violations":[{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078966,"datetime":"2025-12-07T03:42:46Z","files_scanned":1,"total_violations":105,"error_count":0,"warning_count":36,"info_count":69,"violations":[{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078971,"datetime":"2025-12-07T03:42:51Z","files_scanned":1,"total_violations":105,"error_count":0,"warning_count":36,"info_count":69,"violations":[{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF011","file_path":"doeff/_types_internal.py","line":936,"severity":"warning","message":"Function 'visualize_graph_ascii' has flag argument 'use_ascii' with type 'bool'. Accept a callback or protocol object that implements the behavior instead. Example: instead of 'def process(data, use_cache: bool)', use 'def process(data, cache: CacheProtocol)' or 'def process(data, get_cached: Callable)'.","source_line":"use_ascii: bool | None = None,  # noqa: DOEFF013"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078985,"datetime":"2025-12-07T03:43:05Z","files_scanned":1,"total_violations":104,"error_count":0,"warning_count":35,"info_count":69,"violations":[{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765078992,"datetime":"2025-12-07T03:43:12Z","files_scanned":1,"total_violations":104,"error_count":0,"warning_count":35,"info_count":69,"violations":[{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":84,"severity":"warning","message":"Function parameter '_truncate_repr (param 'limit')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":118,"severity":"warning","message":"Variable annotation 'code' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"code: str | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":395,"severity":"warning","message":"Function return type '_find_user_span_end' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":425,"severity":"warning","message":"Function return type '_extract_traceback_path' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":452,"severity":"warning","message":"Function return type 'get_captured_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":472,"severity":"warning","message":"Variable annotation 'runtime_traceback' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_traceback: CapturedTraceback | None = None  # Runtime stack trace where error occurred"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":473,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None = None  # Where the effect was created"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":515,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":522,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":530,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None = field("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":541,"severity":"warning","message":"Function parameter 'with_created_at (param 'created_at')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":589,"severity":"warning","message":"Variable annotation 'created_at' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"created_at: EffectCreationContext | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":659,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":660,"severity":"warning","message":"Variable annotation 'context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"context: EffectCreationContext | None = None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":674,"severity":"warning","message":"Variable annotation 'creation_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"creation_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":675,"severity":"warning","message":"Variable annotation 'cause' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause: BaseException | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":676,"severity":"warning","message":"Variable annotation 'runtime_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"runtime_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":677,"severity":"warning","message":"Variable annotation 'cause_trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":685,"severity":"warning","message":"Variable annotation 'trace' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"trace: CapturedTraceback | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":698,"severity":"warning","message":"Function return type 'from_error' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def from_error(cls, error: Any) -> RunFailureDetails | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function return type 'capture' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[CapturedTraceback]' or 'CapturedTraceback | None', use 'Maybe[CapturedTraceback]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":706,"severity":"warning","message":"Function parameter 'capture (param 'exc')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":722,"severity":"warning","message":"Variable annotation 'cause_exc' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[BaseException]' or 'BaseException | None', use 'Maybe[BaseException]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"cause_exc: BaseException | None = exc.cause if exc.cause else None"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":822,"severity":"warning","message":"Function return type '_failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _failure_details(self) -> RunFailureDetails | None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":855,"severity":"warning","message":"Function return type '_render_error_detail' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _render_error_detail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'use_ascii')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[bool]' or 'bool | None', use 'Maybe[bool]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":928,"severity":"warning","message":"Function parameter 'visualize_graph_ascii (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1063,"severity":"warning","message":"Function parameter '_resolve_graph_style (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _resolve_graph_style(  # noqa: DOEFF006"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function return type '_prepare_decorators' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[str, tuple[str, str]]]' or 'dict[str, tuple[str, str]] | None', use 'Maybe[dict[str, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1089,"severity":"warning","message":"Function parameter '_prepare_decorators (param 'custom_decorators')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[dict[T, tuple[str, str]]]' or 'dict[T, tuple[str, str]] | None', use 'Maybe[dict[T, tuple[str, str]]]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _prepare_decorators("},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1179,"severity":"warning","message":"Variable annotation 'key' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"key: str | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1181,"severity":"warning","message":"Variable annotation 'first_context' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[EffectCreationContext]' or 'EffectCreationContext | None', use 'Maybe[EffectCreationContext]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"first_context: EffectCreationContext | None"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1201,"severity":"warning","message":"Function parameter '_maybe_add_key (param 'key')' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[str]' or 'str | None', use 'Maybe[str]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1259,"severity":"warning","message":"Variable annotation 'failure_details' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[RunFailureDetails]' or 'RunFailureDetails | None', use 'Maybe[RunFailureDetails]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"failure_details: RunFailureDetails | None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF013","file_path":"doeff/_types_internal.py","line":1359,"severity":"warning","message":"Variable annotation 'primary_effect_idx' uses Optional/None type annotation. Consider using doeff's Maybe monad instead for explicit null handling. Example: Instead of 'Optional[int]' or 'int | None', use 'Maybe[int]'. Import with 'from doeff import Maybe, Some, NOTHING' and create values with 'Some(value)' or 'NOTHING'. Use 'Maybe.from_optional(value)' to convert existing Optional values.","source_line":"primary_effect_idx: int | None = None"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF013","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765079185,"datetime":"2025-12-07T03:46:25Z","files_scanned":1,"total_violations":69,"error_count":0,"warning_count":0,"info_count":69,"violations":[{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765079191,"datetime":"2025-12-07T03:46:31Z","files_scanned":2,"total_violations":72,"error_count":0,"warning_count":0,"info_count":72,"violations":[{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":29,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":204,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF022","file_path":"tests/test_to_generator_consistency.py","line":279,"severity":"info","message":"Function 'factory' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def factory(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def factory(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def factory() -> Generator[Effect, Any, int]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":84,"severity":"info","message":"Function '_truncate_repr' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _truncate_repr(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _truncate_repr(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _truncate_repr(obj: object, limit: int | None) -> str:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":122,"severity":"info","message":"Method 'format_location' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_location(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_location(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_location(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":126,"severity":"info","message":"Method 'format_full' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_full(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_full(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_full(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":140,"severity":"info","message":"Method 'build_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def build_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def build_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def build_traceback(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":164,"severity":"info","message":"Method 'without_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def without_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def without_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def without_frames(self) -> EffectCreationContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":241,"severity":"info","message":"Method 'lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def lines("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":260,"severity":"info","message":"Method 'format' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format(  # noqa: DOEFF001"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":285,"severity":"info","message":"Function '_condense_traceback_lines' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _condense_traceback_lines(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _condense_traceback_lines(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _condense_traceback_lines(lines: list[str], max_lines: int) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":311,"severity":"info","message":"Function '_split_traceback_header' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _split_traceback_header(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _split_traceback_header(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _split_traceback_header(lines: list[str]) -> _TracebackSplit:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":317,"severity":"info","message":"Function '_choose_head_tail_lengths' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _choose_head_tail_lengths(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _choose_head_tail_lengths(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _choose_head_tail_lengths(body: list[str], available_frames: int) -> _HeadTailLengths:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":328,"severity":"info","message":"Function '_initial_tail_length' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _initial_tail_length(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _initial_tail_length(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _initial_tail_length(available_frames: int) -> int:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":339,"severity":"info","message":"Function '_rebalance_for_user_frames' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _rebalance_for_user_frames(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _rebalance_for_user_frames(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _rebalance_for_user_frames("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":371,"severity":"info","message":"Function '_grow_head_with_tail' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _grow_head_with_tail(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _grow_head_with_tail(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _grow_head_with_tail("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":395,"severity":"info","message":"Function '_find_user_span_end' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _find_user_span_end(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _find_user_span_end(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _find_user_span_end(body: list[str], desired: int) -> int | None:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":409,"severity":"info","message":"Function '_traceback_frame_spans' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _traceback_frame_spans(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _traceback_frame_spans(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _traceback_frame_spans(body: list[str]) -> list[tuple[int, int]]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":425,"severity":"info","message":"Function '_extract_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _extract_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _extract_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _extract_traceback_path(line: str) -> str | None:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":435,"severity":"info","message":"Function '_is_library_traceback_path' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _is_library_traceback_path(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _is_library_traceback_path(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _is_library_traceback_path(path: str) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":443,"severity":"info","message":"Function 'capture_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture_traceback(exc: BaseException) -> CapturedTraceback:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":452,"severity":"info","message":"Function 'get_captured_traceback' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_captured_traceback(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_captured_traceback(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_captured_traceback(exc: BaseException) -> CapturedTraceback | None:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":517,"severity":"info","message":"Method 'intercept' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def intercept(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def intercept(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def intercept("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":522,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(self: E, created_at: EffectCreationContext | None) -> E:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":541,"severity":"info","message":"Method 'with_created_at' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_created_at(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_created_at(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_created_at(  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":548,"severity":"info","message":"Method 'to_generator' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def to_generator(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def to_generator(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def to_generator(self) -> Generator[Effect | Program, Any, Any]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":625,"severity":"info","message":"Method 'copy' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def copy(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def copy(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def copy(self) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":638,"severity":"info","message":"Method 'with_env_update' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def with_env_update(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def with_env_update(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def with_env_update(self, updates: dict[str, Any]) -> ExecutionContext:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":706,"severity":"info","message":"Function 'capture' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def capture(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def capture(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def capture(exc: BaseException | None) -> CapturedTraceback | None:  # noqa: DOEFF013"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":714,"severity":"info","message":"Function 'walk' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def walk(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def walk(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def walk(exc: BaseException) -> None:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":844,"severity":"info","message":"Method 'format_error' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_error(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_error(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_error(self, *, condensed: bool = False) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":912,"severity":"info","message":"Method 'display' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def display(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def display(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def display(self, verbose: bool = False, indent: int = 2) -> str:  # noqa: DOEFF011"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":928,"severity":"info","message":"Method 'visualize_graph_ascii' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def visualize_graph_ascii(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def visualize_graph_ascii(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def visualize_graph_ascii(  # noqa: DOEFF011"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":978,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1020,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1079,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1135,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF014","file_path":"doeff/_types_internal.py","line":1154,"severity":"info","message":"Native try-except works in @do functions. For complex error handling, consider effect-based alternatives: `Safe(program)` for Result object, `program.recover(fallback)` for fallbacks, `Catch(program, handler)` to transform errors. These enable better composability and explicit error flow.","source_line":"try:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1201,"severity":"info","message":"Function '_maybe_add_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _maybe_add_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _maybe_add_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _maybe_add_key(effect_type: str, key: str | None) -> None:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1245,"severity":"info","message":"Method 'is_empty' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def is_empty(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def is_empty(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def is_empty(self) -> bool:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1248,"severity":"info","message":"Method 'keys_for' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def keys_for(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def keys_for(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def keys_for(self, effect_type: str) -> tuple[str | None, ...]:  # noqa: DOEFF006"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1262,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1272,"severity":"info","message":"Method 'indent' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def indent(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def indent(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def indent(self, level: int, text: str) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1275,"severity":"info","message":"Method 'format_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def format_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def format_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def format_value(self, value: Any, *, max_length: int = 200) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1283,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1288,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1352,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1496,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1513,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1530,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1546,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1586,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1611,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1630,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1662,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1702,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> list[str]:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1725,"severity":"info","message":"Method 'render' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def render(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def render(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def render(self) -> str:"},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1769,"severity":"info","message":"Function '_intercept_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_value("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1797,"severity":"info","message":"Function '_intercept_mapping' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _intercept_mapping(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _intercept_mapping(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _intercept_mapping("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1810,"severity":"info","message":"Function '_wrap_callable' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def _wrap_callable(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def _wrap_callable(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def _wrap_callable("},{"rule_id":"DOEFF022","file_path":"doeff/_types_internal.py","line":1816,"severity":"info","message":"Function 'wrapper' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def wrapper(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def wrapper(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def wrapper(*args: Any, **kwargs: Any) -> Any:"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765245459,"datetime":"2025-12-09T01:57:39Z","files_scanned":1,"total_violations":3,"error_count":1,"warning_count":1,"info_count":1,"violations":[{"rule_id":"DOEFF009","file_path":"/tmp/test_exclude.py","line":2,"severity":"warning","message":"Function 'foo' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def foo():"},{"rule_id":"DOEFF010","file_path":"/tmp/test_exclude.py","line":1,"severity":"error","message":"Test file 'test_exclude.py' must be placed under a 'tests' directory. Move to tests/test_exclude.py or tests/unit/test_exclude.py, etc.","source_line":"# test file"},{"rule_id":"DOEFF022","file_path":"/tmp/test_exclude.py","line":2,"severity":"info","message":"Function 'foo' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def foo(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def foo(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def foo():"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
{"timestamp":1765245474,"datetime":"2025-12-09T01:57:54Z","files_scanned":1,"total_violations":27,"error_count":6,"warning_count":10,"info_count":11,"violations":[{"rule_id":"DOEFF001","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":9,"severity":"warning","message":"Function 'dict' shadows Python built-in 'dict'. Use a more descriptive name like 'dict_impl' or 'create_dict'.","source_line":"def dict():  # Should trigger DOEFF001"},{"rule_id":"DOEFF009","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":9,"severity":"warning","message":"Function 'dict' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def dict():  # Should trigger DOEFF001"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":9,"severity":"info","message":"Function 'dict' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def dict(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def dict(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def dict():  # Should trigger DOEFF001"},{"rule_id":"DOEFF002","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":19,"severity":"error","message":"Attribute 'count' in class 'Counter' is mutated outside __init__/__post_init__. Mutable attributes must be prefixed with 'mut_'.","source_line":"self.count += 1  # Should trigger DOEFF002 - not using mut_ prefix"},{"rule_id":"DOEFF009","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":18,"severity":"warning","message":"Method 'increment' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def increment(self):"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":18,"severity":"info","message":"Method 'increment' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def increment(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def increment(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def increment(self):"},{"rule_id":"DOEFF004","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":24,"severity":"error","message":"Direct access to os.environ is forbidden. Use dependency injection to receive configuration values.","source_line":"return os.environ[\"API_KEY\"]  # Should trigger DOEFF004"},{"rule_id":"DOEFF009","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":23,"severity":"warning","message":"Function 'get_api_key' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def get_api_key():"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":23,"severity":"info","message":"Function 'get_api_key' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_api_key(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_api_key(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_api_key():"},{"rule_id":"DOEFF004","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":24,"severity":"error","message":"Direct access to os.environ is forbidden. Use dependency injection to receive configuration values.","source_line":"return os.environ[\"API_KEY\"]  # Should trigger DOEFF004"},{"rule_id":"DOEFF002","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":33,"severity":"error","message":"Attribute '_value' in class 'Config' is mutated outside __init__/__post_init__. Mutable attributes must be prefixed with '_mut'.","source_line":"self._value = value"},{"rule_id":"DOEFF005","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":32,"severity":"warning","message":"Setter method 'set_value' in class 'Config' is not allowed. Prefer immutable patterns: use constructor parameters, dataclasses.replace(), or 'with_*' methods that return new instances.","source_line":"def set_value(self, value):  # Should trigger DOEFF005"},{"rule_id":"DOEFF009","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":32,"severity":"warning","message":"Method 'set_value' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def set_value(self, value):  # Should trigger DOEFF005"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":32,"severity":"info","message":"Method 'set_value' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def set_value(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def set_value(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def set_value(self, value):  # Should trigger DOEFF005"},{"rule_id":"DOEFF006","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":37,"severity":"error","message":"Function 'get_user_info' returns a tuple. Use a dataclass instead for structured return values. Example: Instead of 'def get_user() -> tuple[str, int]', use '@dataclass class User: name: str; age: int' and 'def get_user() -> User'.","source_line":"def get_user_info() -> Tuple[str, int]:  # Should trigger DOEFF006"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":37,"severity":"info","message":"Function 'get_user_info' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def get_user_info(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def get_user_info(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def get_user_info() -> Tuple[str, int]:  # Should trigger DOEFF006"},{"rule_id":"DOEFF007","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":43,"severity":"error","message":"Function 'process_items' mutates argument 'items' by calling 'append()'. Return a new collection instead.","source_line":"items.append(\"new\")  # Should trigger DOEFF007"},{"rule_id":"DOEFF009","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":42,"severity":"warning","message":"Function 'process_items' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def process_items(items):"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":42,"severity":"info","message":"Function 'process_items' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def process_items(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def process_items(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def process_items(items):"},{"rule_id":"DOEFF009","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":54,"severity":"warning","message":"Function 'update_person' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def update_person(person: Person):"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":54,"severity":"info","message":"Function 'update_person' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def update_person(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def update_person(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def update_person(person: Person):"},{"rule_id":"DOEFF009","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":59,"severity":"warning","message":"Function 'add' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def add(a: int, b: int):  # Should trigger DOEFF009"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":59,"severity":"info","message":"Function 'add' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def add(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def add(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def add(a: int, b: int):  # Should trigger DOEFF009"},{"rule_id":"DOEFF009","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":68,"severity":"warning","message":"Method 'increment' is missing a return type annotation. Add '-> ReturnType' for better type safety.","source_line":"def increment(self):"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":68,"severity":"info","message":"Method 'increment' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def increment(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def increment(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def increment(self):"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":72,"severity":"info","message":"Function 'good_function' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def good_function(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def good_function(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def good_function(x: int) -> int:  # Has return type"},{"rule_id":"DOEFF022","file_path":"packages/doeff-linter/tests/fixtures/test_sample.py","line":76,"severity":"info","message":"Function 'process_items_good' is not decorated with @do.\n\nRecommendation: Consider using the @do decorator to enable doeff's structured effects:\n  - Effect tracking for IO, async, and side effects\n  - Structured logging with `yield slog(\"message\", key=value)`\n  - Composition with other Program functions\n\nExample:\n  # Before\n  def process_items_good(...) -> ReturnType:\n      ...\n  \n  # After\n  @do\n  def process_items_good(...) -> EffectGenerator[ReturnType]:\n      yield slog(\"Processing\", ...)  # optional structured logging\n      ...\n\nIf this function intentionally doesn't use doeff effects, suppress with: # noqa: DOEFF022","source_line":"def process_items_good(items: list) -> list:  # Returns new list"}],"run_mode":"normal","enabled_rules":["DOEFF001","DOEFF002","DOEFF003","DOEFF004","DOEFF005","DOEFF006","DOEFF007","DOEFF008","DOEFF009","DOEFF010","DOEFF011","DOEFF012","DOEFF014","DOEFF015","DOEFF016","DOEFF017","DOEFF018","DOEFF019","DOEFF020","DOEFF021","DOEFF022","DOEFF023"]}
