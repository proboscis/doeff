# doeff: Algebraic Effects for Python

English blog post series outline.

---

## Target Audience

- Python developers familiar with async/await
- Interested in better architecture, testability
- Curious about functional programming but intimidated by monads
- Game developers, simulation engineers, backend developers

---

## Post Series

### Post 1: "Why Your Python Code is Hard to Test (And How to Fix It)"

- Hook: The mock hell problem
- Problem: "What" and "How" are mixed
- Solution preview: Effects separate them
- Teaser: doeff

### Post 2: "Algebraic Effects Explained for Python Developers"

- What are algebraic effects (intuition, not theory)
- yield as "pause and ask"
- Handlers decide "how"
- Simple examples

### Post 3: "Building a Pure Core with doeff"

- Installation & quick start
- Basic effects: Reader, State, Writer
- The Pure Core pattern
- Testing becomes trivial

### Post 4: "The Architecture Behind doeff"

- Generators as delimited continuations
- Structured logging for execution traces
- Visualizing program flow with Kleisli transforms
- Comparison with OCaml 5, Koka
- What doeff CAN'T do (generators not serializable)
- When to use this approach

### Post 5: "Case Study: Building a Card Game with Algebraic Effects"

- Real-world example from card_game_2026
- UI/Logic separation
- Save/Load/Replay for free
- Lessons learned

---

## Status

| Post | Status |
|------|--------|
| 1 | Not started |
| 2 | Not started |
| 3 | Not started |
| 4 | Not started |
| 5 | Not started |
