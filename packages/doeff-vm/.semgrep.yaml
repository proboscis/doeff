rules:
  # =============================================================================
  # DOEFF-VM SPEC ENFORCEMENT RULES
  # =============================================================================
  # These rules enforce SPEC-008 Rev 9 and SPEC-009 Rev 3 invariants.
  # They exist as structural assertions alongside unit tests.
  #
  # Run: semgrep --config packages/doeff-vm/.semgrep.yaml packages/doeff-vm/src/
  # =============================================================================

  # ---------------------------------------------------------------------------
  # ADR-13 / INV-9: run() must use WithHandler nesting, not install_handler
  # ---------------------------------------------------------------------------

  - id: doeff-vm-no-install-handler-in-run
    pattern-regex: '(?s)#\[pyfunction\].*?fn run\b.*?install_handler'
    message: |
      SPEC VIOLATION (ADR-13, INV-9): install_handler() called in module-level
      run() function. run() must install handlers via WithHandler nesting chain,
      not via direct install_handler() bypass.

      The correct implementation builds a NestingStep chain and processes each
      WithHandler through the normal VM handle_with_handler mechanism, creating
      proper PromptBoundary segments and scope chains.

      See: SPEC-008 ADR-13, INV-9, INV-16
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["ADR-13", "INV-9", "INV-16"]

  # ---------------------------------------------------------------------------
  # ADR-14: No string-based handler shortcuts
  # ---------------------------------------------------------------------------

  - id: doeff-vm-no-string-handler-shortcuts
    pattern-regex: '(?s)#\[pyfunction\].*?fn run\b.*?extract::<String>'
    message: |
      SPEC VIOLATION (ADR-14): String-based handler shortcuts (e.g., "state",
      "reader") used in run(). Handlers must be PyRustHandlerSentinel objects,
      not strings.

      Use: run(program, handlers=[state, reader, writer])
      where state/reader/writer are PyRustHandlerSentinel instances exposed
      at module level.

      See: SPEC-008 ADR-14
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["ADR-14"]

  # ---------------------------------------------------------------------------
  # SPEC-009 API-12: async_run must be truly async
  # ---------------------------------------------------------------------------

  - id: doeff-vm-async-run-no-sync-delegation
    pattern-regex: '(?s)fn async_run\b.*?let result = run\('
    message: |
      SPEC VIOLATION (API-12): async_run() delegates to sync run() internally.
      async_run must be a true async function that yields control to the event
      loop, not a sync function wrapped in a coroutine.

      See: SPEC-009 API-12
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-009
      invariants: ["API-12"]

  - id: doeff-vm-no-ensure-future-wrapping
    pattern-regex: '(?s)fn async_run\b.*?ensure_future'
    message: |
      SPEC VIOLATION (API-12): async_run() uses ensure_future() to wrap a
      synchronous result. This is not true async — it blocks the thread
      during execution and only wraps the completed result.

      async_run must yield to the event loop during execution.

      See: SPEC-009 API-12
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-009
      invariants: ["API-12"]

  # ---------------------------------------------------------------------------
  # SPEC-009: RunResult Python-exposed name
  # ---------------------------------------------------------------------------

  - id: doeff-vm-runresult-python-name
    pattern-regex: '#\[pyclass\(frozen\)\]\s*\n\s*pub struct PyRunResult'
    message: |
      SPEC VIOLATION: PyRunResult must be exposed to Python as "RunResult".
      Use #[pyclass(frozen, name = "RunResult")] instead of #[pyclass(frozen)].

      See: SPEC-009 §2
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-009

  # ---------------------------------------------------------------------------
  # ADR-12: Correctness-first — no install_handler in user-facing APIs
  # ---------------------------------------------------------------------------

  - id: doeff-vm-no-install-handler-in-async-run
    pattern-regex: '(?s)fn async_run\b.*?install_handler'
    message: |
      SPEC VIOLATION (ADR-13): install_handler() called in async_run().
      async_run() must use WithHandler nesting, identical to run().

      See: SPEC-008 ADR-13
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["ADR-13"]

  # ---------------------------------------------------------------------------
  # R13-I: GIL-free tag dispatch enforcement
  # ---------------------------------------------------------------------------

  - id: doeff-vm-doctrl-base-must-have-tag
    pattern-regex: 'pub struct PyDoCtrlBase\s*;'
    message: |
      SPEC VIOLATION (R13-I): PyDoCtrlBase must have a `tag: u8` field for
      GIL-free tag dispatch. Empty unit struct `PyDoCtrlBase;` is not allowed.

      Use: pub struct PyDoCtrlBase { pub tag: u8 }

      See: SPEC-008 R13-I
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["R13-I"]

  - id: doeff-vm-effect-base-must-have-tag
    pattern-regex: 'pub struct PyEffectBase\s*;'
    message: |
      SPEC VIOLATION (R13-I): PyEffectBase must have a `tag: u8` field for
      GIL-free tag dispatch. Empty unit struct `PyEffectBase;` is not allowed.

      Use: pub struct PyEffectBase { pub tag: u8 }

      See: SPEC-008 R13-I
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["R13-I"]

  - id: doeff-vm-no-isinstance-chain-in-classify
    pattern-regex: '(?s)fn classify_yielded\b.*?extract::<PyRef.*?extract::<PyRef.*?extract::<PyRef'
    message: |
      SPEC VIOLATION (R13-I): classify_yielded contains 3+ sequential
      extract::<PyRef<_>> calls. Use tag-based dispatch instead.

      Read PyDoCtrlBase.tag first, then match on DoExprTag to do a single
      targeted extract for the specific variant.

      See: SPEC-008 R13-I
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["R13-I"]

  - id: doeff-vm-classify-must-read-tag-first
    pattern-regex: "(?s)fn classify_yielded\\b[^}]*?extract::<PyRef<'_, Py(?:WithHandler|Pure|Call|Map|FlatMap|Perform|Resume)>>[^}]*?extract::<PyRef<'_, PyDoCtrlBase>>"
    message: |
      SPEC VIOLATION (R13-I): classify_yielded extracts a concrete variant
      before extracting PyDoCtrlBase. The tag must be read from PyDoCtrlBase
      first, then a single targeted extract based on the tag value.

      See: SPEC-008 R13-I
    languages: [generic]
    severity: WARNING
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["R13-I"]

  - id: doeff-vm-doctrl-constructor-must-set-tag
    pattern-regex: '\.add_subclass\(PyDoCtrlBase\)'
    message: |
      SPEC VIOLATION (R13-I): PyDoCtrlBase constructed without tag field.
      Every .add_subclass(PyDoCtrlBase) must set the tag field:
      .add_subclass(PyDoCtrlBase { tag: DoExprTag::Xxx as u8 })

      See: SPEC-008 R13-I
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/pyvm.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["R13-I"]

  - id: doeff-vm-effect-constructor-must-set-tag
    pattern-regex: 'PyClassInitializer::from\(PyEffectBase\)\.'
    message: |
      SPEC VIOLATION (R13-I): PyEffectBase constructed without tag field.
      Every PyClassInitializer::from(PyEffectBase) must set the tag:
      PyClassInitializer::from(PyEffectBase { tag: DoExprTag::Effect as u8 })

      See: SPEC-008 R13-I
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/effect.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["R13-I"]

  # ---------------------------------------------------------------------------
  # SPEC-VM-013 ENFORCEMENT
  # ---------------------------------------------------------------------------

  - id: vm-no-exception-spawn-boundaries-global
    pattern: EXCEPTION_SPAWN_BOUNDARIES
    message: |
      SPEC-VM-013 violation: EXCEPTION_SPAWN_BOUNDARIES global static must not exist.
      Spawn-boundary context must flow through GetExecutionContext and typed execution context.
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/scheduler.rs"
    metadata:
      spec: SPEC-VM-013
      category: vm-protocol

  - id: vm-no-take-exception-spawn-boundaries
    pattern-regex: '\bfn\s+take_exception_spawn_boundaries\b'
    message: |
      SPEC-VM-013 violation: take_exception_spawn_boundaries must not exist.
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/scheduler.rs"
    metadata:
      spec: SPEC-VM-013
      category: vm-protocol

  - id: vm-no-preserve-exception-origin
    pattern-regex: '\bfn\s+preserve_exception_origin\b'
    message: |
      SPEC-VM-013 violation: preserve_exception_origin must not exist.
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/scheduler.rs"
        - "**/doeff-vm/src/handler.rs"
    metadata:
      spec: SPEC-VM-013
      category: vm-protocol

  - id: vm-no-doeff-exception-origin-dunder
    pattern-regex: '__doeff_exception_origin__'
    message: |
      SPEC-VM-013 violation: __doeff_exception_origin__ dunder is forbidden.
      Use typed doeff_execution_context enrichment instead.
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/**"
    metadata:
      spec: SPEC-VM-013
      category: vm-protocol

  - id: vm-no-exception-spawn-boundary-struct
    pattern-regex: '\bstruct\s+ExceptionSpawnBoundary\b'
    message: |
      SPEC-VM-013 violation: ExceptionSpawnBoundary struct must not exist.
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/scheduler.rs"
    metadata:
      spec: SPEC-VM-013
      category: vm-protocol

  # ---------------------------------------------------------------------------
  # R14-C: Perform lowering enforcement
  # ---------------------------------------------------------------------------

  - id: doeff-vm-no-yielded-effect-variant
    pattern-regex: 'Yielded::Effect'
    message: |
      SPEC VIOLATION (R14-C): Yielded::Effect variant must not exist.
      All bare effects must be lowered to Perform(effect) at the IR boundary.
      classify_yielded wraps bare EffectBase instances as DoCtrl::Perform.

      See: SPEC-008 R14-C
    languages: [generic]
    severity: ERROR
    paths:
      include:
        - "**/doeff-vm/src/yielded.rs"
    metadata:
      category: spec-enforcement
      spec: SPEC-008
      invariants: ["R14-C"]
