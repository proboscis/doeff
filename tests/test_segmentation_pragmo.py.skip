"""Test the pragmatic free monad segmentation implementation."""

from typing import Any, Generator, Union
import asyncio
import numpy as np
import PIL.Image

import pytest
from pinjected import design, AsyncResolver

from doeff import (
    ProgramInterpreter,
    ExecutionContext,
    Effect,
    do,
    Step,
    Annotate,
    Program,
    Log,
    Await,
)
from doeff import program_to_injected
from sge_hub.agentic_segmentation.segmentation_pragmo import (
    overlay,
    test_eyebrow_program,
    test_skin_program,
    extract_colored_mask,
)


@pytest.mark.asyncio
async def test_overlay_effect():  # noqa: PINJ040
    """Test the overlay function using pragmatic monad."""
    # Create test images
    base_image = PIL.Image.new("RGB", (100, 100), color="white")
    result_image = PIL.Image.new("RGB", (100, 100), color="white")

    # Add some red pixels to result image
    pixels = result_image.load()
    for i in range(20, 40):
        for j in range(20, 40):
            pixels[i, j] = (255, 0, 0)  # Red

    # Run overlay program
    program = overlay(base_image, result_image)
    engine = ProgramInterpreter()
    context = ExecutionContext()

    result = await engine.run(program, context)
    assert result.is_ok
    assert isinstance(result.value, PIL.Image.Image)
    assert result.value.mode == "RGBA"

    # Check graph has overlay step
    assert any("overlay" in str(step.meta) for step in result.graph.steps)


@pytest.mark.asyncio
async def test_extract_colored_mask():  # noqa: PINJ040
    """Test the extract_colored_mask function."""
    # Create test image with red region
    test_image = PIL.Image.new("RGB", (100, 100), color="white")
    pixels = test_image.load()
    for i in range(30, 60):
        for j in range(30, 60):
            pixels[i, j] = (250, 5, 5)  # Almost pure red

    # Define a simple extraction function locally to test the logic

    # Run extraction
    program = extract_colored_mask(test_image, color="#ff0000")
    engine = ProgramInterpreter()
    context = ExecutionContext()

    result = await engine.run(program, context)
    assert result.is_ok
    assert isinstance(result.value, np.ndarray)
    assert result.value.dtype == np.bool_
    assert result.value.shape == (100, 100)

    # Check that red region is detected
    assert np.sum(result.value[30:60, 30:60]) > 0

    # Check graph has extract step
    assert any("extract_colored_mask" in str(step.meta) for step in result.graph.steps)


@pytest.mark.asyncio
async def test_program_functions():  # noqa: PINJ040
    """Test the test_eyebrow_program and test_skin_program Programs."""
    # These are directly Program objects, not functions
    eyebrow_prog = test_eyebrow_program
    skin_prog = test_skin_program

    assert isinstance(eyebrow_prog, Program)
    assert isinstance(skin_prog, Program)

    # Check they have generator_func attribute
    assert hasattr(eyebrow_prog, "generator_func")
    assert hasattr(skin_prog, "generator_func")


@pytest.mark.asyncio
async def test_pinjected_bridge_integration():  # noqa: PINJ040
    """Test that Programs can be converted to Injected using the bridge."""

    # Create a simple test program
    @do
    def simple_test() -> Generator[Effect, Any, str]:
        yield Step("step1", {"test": True})
        yield Annotate({"phase": "testing"})
        return "test_result"

    # Convert to Injected
    program = simple_test()
    injected = program_to_injected(program)

    # Create a test resolver
    test_design = design()
    resolver = AsyncResolver(test_design)  # pinjected: allow-async-resolver

    # Run through pinjected
    result = await resolver.provide(injected)
    assert result == "test_result"


@pytest.mark.asyncio
async def test_graph_tracking():  # noqa: PINJ040
    """Test that graph steps are properly tracked."""

    @do
    def graph_test() -> Generator[Effect, Any, int]:
        yield Step("value1", {"index": 1})
        yield Step("value2", {"index": 2})
        yield Annotate({"total_steps": 2})
        yield Step("value3", {"index": 3})
        return 42

    engine = ProgramInterpreter()
    context = ExecutionContext()

    result = await engine.run(graph_test(), context)
    assert result.is_ok
    assert result.value == 42

    # Check graph has all steps (including initial)
    assert len(result.graph.steps) == 4  # 3 explicit + 1 initial

    # Check that we have steps with metadata
    steps_with_index = [
        s for s in result.graph.steps if any("index" in str(s.meta) for _ in [s])
    ]
    assert len(steps_with_index) == 3  # Should have 3 steps with index metadata


@pytest.mark.asyncio
async def test_aggregate_segmentations_parallel():  # noqa: PINJ040
    """Test that aggregate_segmentations uses Gather for parallel execution."""
    import time

    @do
    def slow_extractor(
        delay: float, value: int
    ) -> Generator[Union[Effect, Program], Any, np.ndarray]:
        """Simulate a slow extractor with a delay."""
        yield Log(f"Starting extractor with delay {delay}")
        # Simulate slow async operation
        start_time = time.time()
        yield Await(asyncio.sleep(delay))
        elapsed = time.time() - start_time
        yield Log(f"Extractor completed after {elapsed:.2f}s")
        # Return a simple mask
        mask = np.zeros((10, 10), dtype=np.bool_)
        mask[value, :] = True  # Different row for each extractor
        return mask

    # Create extractors with different delays
    from sge_hub.agentic_segmentation.segmentation_pragmo import FuncExtractor

    extractors = [
        FuncExtractor(func=lambda img: slow_extractor(0.1, 0), name="fast"),
        FuncExtractor(func=lambda img: slow_extractor(0.2, 1), name="medium"),
        FuncExtractor(func=lambda img: slow_extractor(0.3, 2), name="slow"),
    ]

    # Create a dummy image
    test_img = PIL.Image.new("RGB", (10, 10))

    # Run aggregate_segmentations
    from sge_hub.agentic_segmentation.segmentation_pragmo import aggregate_segmentations

    start_time = time.time()
    prog = aggregate_segmentations(test_img, extractors)

    engine = ProgramInterpreter()
    result = await engine.run(prog)
    elapsed = time.time() - start_time

    assert result.is_ok
    # With parallel execution, should take ~0.3s (max delay), not 0.6s (sum of delays)
    assert elapsed < 0.5, f"Parallel execution took {elapsed:.2f}s, expected < 0.5s"

    # Check the result mask
    mask = result.value
    assert mask.shape == (10, 10)
    # Each extractor marks a different row
    assert np.all(mask[0, :] == 1)  # First extractor
    assert np.all(mask[1, :] == 2)  # Second extractor
    assert np.all(mask[2, :] == 3)  # Third extractor

    # Check logs show parallel execution
    assert "Starting parallel extraction for 3 extractors" in result.log
    assert "Executing all extractors in parallel..." in result.log
    assert "Aggregation complete: 3 masks combined" in result.log


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
