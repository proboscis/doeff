rules:
  # =============================================================================
  # DOEFF ARCHITECTURAL ENFORCEMENT RULES
  # =============================================================================
  # These rules enforce architectural decisions specific to the doeff framework.
  # For code quality patterns (immutability, naming), see doeff-linter (Rust).
  # 
  # Install semgrep: uv tool install semgrep
  # Run: semgrep --config .semgrep.yaml doeff/ packages/
  # =============================================================================

  # ---------------------------------------------------------------------------
  # EFFECT SYSTEM PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-python-side-cancel-state
    patterns:
      - pattern-either:
          - pattern: _cancelled_task_ids
          - pattern: _cancelled_task_ids.add(...)
          - pattern: _cancelled_task_ids.discard(...)
          - pattern: $X in _cancelled_task_ids
    paths:
      include:
        - "**/doeff/**"
      exclude:
        - "**/tests/**"
    message: |
      BANNED: Python-side cancel state management.
      Cancellation state belongs in the Rust scheduler (`cancel_requested: HashSet<TaskId>`).
      Task.cancel() must yield a PyCancelEffect, not mutate Python globals.
      See SPEC-SCHED-001 §Cancel, ISSUE-CORE-502.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Cancel state ownership — SPEC-SCHED-001, ISSUE-CORE-502"

  - id: doeff-no-python-task-id-extraction
    patterns:
      - pattern-inside: |
          class Task:
              ...
      - pattern: task_id_of(...)
    paths:
      include:
        - "**/doeff/effects/spawn.py"
    message: |
      BANNED: Python code must not extract task_id from Rust handles for scheduler operations.
      Task operations (cancel, is_done) should yield effects handled by the Rust scheduler.
      The Python layer should not inspect or decode Rust-internal handle structures.
      See SPEC-SCHED-001 §PyTask, ISSUE-CORE-502.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Layer boundary — Python must not inspect Rust handle internals"

  - id: doeff-no-rust-poll-python-cancel-state
    pattern-regex: 'getattr\("_cancelled_task_ids"\)'
    paths:
      include:
        - "**/packages/doeff-vm/src/**"
    message: |
      BANNED: Rust scheduler must not poll Python for cancellation state.
      The scheduler owns cancel_requested via PyCancelEffect handler.
      Remove GIL round-trip polling of _cancelled_task_ids.
      See SPEC-SCHED-001, ISSUE-CORE-502.
    languages: [rust]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Scheduler state ownership — cancel state lives in Rust"

  - id: doeff-cancel-must-be-effectful
    patterns:
      - pattern-inside: |
          class Task:
              ...
      - pattern: |
          def cancel(self):
              ...
              return Program.pure(...)
    paths:
      include:
        - "**/doeff/effects/spawn.py"
    message: |
      BANNED: Task.cancel() must yield an effect, not return Program.pure().
      Cancel is a scheduler operation — it must go through effect dispatch.
      Use: return create_effect_with_trace(TaskCancelEffect(task=self), ...)
      See SPEC-SCHED-001 §PyTask, ISSUE-CORE-502.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Cancel must be effectful per SPEC-SCHED-001"

  - id: doeff-no-direct-generator-in-do
    patterns:
      - pattern: |
          @do
          def $FUNC(...):
              ...
              yield from $EXPR
              ...
    paths:
      exclude:
        - "**/tests/**"
    message: |
      Do not use `yield from` in @do functions. Each effect should be yielded individually
      to maintain proper effect tracking and call tree construction.
      Use: `result = yield sub_program()` instead of `yield from sub_program()`.
    languages: [python]
    severity: ERROR
    metadata:
      category: effect-system
      rationale: "yield from bypasses effect tracking and breaks call tree construction"

  - id: doeff-no-async-in-do-function
    pattern-regex: '@do\s*\n\s*async\s+def\s+\w+'
    paths:
      exclude:
        - "**/examples/marker_patterns.py"
    message: |
      @do functions should not be async. The @do decorator handles async execution
      through the effect system. Remove 'async' keyword and use Await effect for
      async operations: `result = yield Await(async_func())`.
    languages: [python]
    severity: ERROR
    metadata:
      category: effect-system
      rationale: "@do functions use generator-based concurrency, not async/await"

  - id: doeff-no-bare-return-in-generator
    patterns:
      - pattern: |
          @do
          def $FUNC(...):
              ...
              return
    message: |
      @do functions should return a value, not bare `return`. If no value is needed,
      use `return None` explicitly for clarity.
    languages: [python]
    severity: WARNING
    metadata:
      category: effect-system

  # ---------------------------------------------------------------------------
  # LAYER BOUNDARIES
  # ---------------------------------------------------------------------------

  - id: doeff-no-handler-import-in-effects
    patterns:
      - pattern-inside: |
          # In doeff/effects/ directory
          ...
      - pattern-either:
          - pattern: from doeff.handlers import $X
          - pattern: from doeff.handlers.$MOD import $X
          - pattern: import doeff.handlers
    paths:
      include:
        - "**/doeff/effects/"
    message: |
      Effects should not import from handlers. This violates layer separation.
      Effects define WHAT operations are available; handlers define HOW to execute them.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Effects layer must not depend on handlers layer"

  - id: doeff-no-runtime-import-in-effects
    patterns:
      - pattern-either:
          - pattern: from doeff.runtimes import $X
          - pattern: from doeff.interpreter import $X
          - pattern: import doeff.runtimes
    paths:
      include:
        - "**/doeff/effects/"
    message: |
      Effects should not import from runtimes or interpreter. This violates layer separation.
      Effects are pure data structures describing operations.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture

  - id: doeff-no-handler-modification-in-run
    patterns:
      - pattern-either:
          - pattern: _normalize_async_handlers(...)
          - pattern: _needs_threaded_async_driver(...)
    paths:
      include:
        - "**/doeff/"
    message: |
      Handler lists must never be modified by run() or async_run().
      Handler selection is the user's responsibility. Remove handler
      normalization/detection functions.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Handler immutability invariant — SPEC-EFF-011, ISSUE-CORE-495"

  - id: doeff-no-thread-offload-in-async-run
    patterns:
      - pattern: asyncio.to_thread(...)
    paths:
      include:
        - "**/doeff/rust_vm.py"
    message: |
      async_run must not offload VM stepping to a background thread.
      The VM step loop should run on the caller's event loop.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "VM boundary invariant — SPEC-EFF-011, ISSUE-CORE-495"

  # ---------------------------------------------------------------------------
  # PURITY PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-print-in-core
    patterns:
      - pattern: print(...)
    paths:
      include:
        - "**/doeff/"
      exclude:
        - "**/doeff/__main__.py"
        - "**/doeff/cli/"
        - "**/tests/**"
        - "**/examples/**"
    message: |
      Do not use print() in core library code. Use the Log effect for logging:
      `yield Log("message")` or configure loguru for internal debugging.
    languages: [python]
    severity: WARNING
    metadata:
      category: purity

  - id: doeff-no-datetime-now-in-do
    patterns:
      - pattern-inside: |
          @do
          def $FUNC(...):
              ...
      - pattern-either:
          - pattern: datetime.now(...)
          - pattern: datetime.datetime.now(...)
          - pattern: datetime.utcnow(...)
          - pattern: datetime.datetime.utcnow(...)
    message: |
      Do not call datetime.now() directly in @do functions. This makes the function
      impure and hard to test. Use the GetTime effect instead:
      `current_time = yield GetTime()`.
    languages: [python]
    severity: WARNING
    metadata:
      category: purity

  - id: doeff-no-random-in-do
    patterns:
      - pattern-inside: |
          @do
          def $FUNC(...):
              ...
      - pattern-either:
          - pattern: random.random(...)
          - pattern: random.randint(...)
          - pattern: random.choice(...)
          - pattern: random.shuffle(...)
    message: |
      Do not use random module directly in @do functions. This makes the function
      impure. Consider wrapping in an IO effect or injecting via Ask.
    languages: [python]
    severity: WARNING
    metadata:
      category: purity

  # ---------------------------------------------------------------------------
  # DEPENDENCY INJECTION PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-hardcoded-instantiation-in-do
    patterns:
      - pattern-inside: |
          @do
          def $FUNC(...):
              ...
      - pattern-either:
          - pattern: $CLIENT = httpx.Client(...)
          - pattern: $CLIENT = httpx.AsyncClient(...)
          - pattern: $CONN = sqlite3.connect(...)
          - pattern: $ENGINE = create_engine(...)
    message: |
      Do not instantiate clients/connections directly in @do functions. 
      Use dependency injection via the Ask effect:
      `client = yield Ask("http_client")`.
    languages: [python]
    severity: WARNING
    metadata:
      category: dependency-injection

  # ---------------------------------------------------------------------------
  # CONCURRENCY API MIGRATION (SPEC-EFF-005 Redesign)
  # ---------------------------------------------------------------------------
  # These rules detect old concurrency patterns that need migration to the new
  # Future-based API. See specs/effects/SPEC-EFF-005-concurrency.md.

  - id: doeff-task-join-deprecated
    pattern: $TASK.join()
    message: |
      MIGRATION: task.join() is deprecated. Use Wait(task) instead.

      OLD: result = yield task.join()
      NEW: result = yield Wait(task)

      See SPEC-EFF-005 for details.
    languages: [python]
    severity: WARNING
    metadata:
      category: concurrency-migration
      spec: SPEC-EFF-005

  # ---------------------------------------------------------------------------
  # DEPRECATED EFFECT NAMES
  # ---------------------------------------------------------------------------

  - id: doeff-no-future-await-effect
    patterns:
      - pattern-either:
          - pattern: FutureAwaitEffect
          - pattern: from doeff.effects.future import FutureAwaitEffect
          - pattern: from doeff.effects import FutureAwaitEffect
    paths:
      exclude:
        # Allow in the definition file where the alias is defined
        - "**/doeff/effects/future.py"
        - "**/doeff/effects/__init__.py"
    message: |
      DEPRECATED: FutureAwaitEffect is renamed to PythonAsyncioAwaitEffect.

      This effect is specifically for Python asyncio awaitables, not a generic
      "future" abstraction. Use the new name for clarity:

      OLD: from doeff.effects import FutureAwaitEffect
      NEW: from doeff.effects import PythonAsyncioAwaitEffect

      Or just use the public API: yield Await(coroutine)
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-names
      rationale: "FutureAwaitEffect is misleading - it's Python asyncio specific"

  # ---------------------------------------------------------------------------
  # TESTING PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-sleep-in-tests
    patterns:
      - pattern-either:
          - pattern: time.sleep(...)
          - pattern: await asyncio.sleep(...)
    paths:
      include:
        - tests/
    message: |
      Avoid time.sleep() or asyncio.sleep() in tests. Use SimulationRuntime
      with controlled time for deterministic testing.
    languages: [python]
    severity: WARNING
    metadata:
      category: testing

  # ---------------------------------------------------------------------------
  # IMPORT HYGIENE
  # ---------------------------------------------------------------------------

  - id: doeff-no-star-imports
    patterns:
      - pattern: from $MODULE import *
    paths:
      exclude:
        - "**/__init__.py"
    message: |
      Do not use star imports (from x import *). Import specific names
      for clarity and to avoid namespace pollution.
    languages: [python]
    severity: WARNING
    metadata:
      category: imports

  - id: doeff-no-typing-any-in-public-api
    patterns:
      - pattern-either:
          - pattern: |
              def $FUNC($...PARAMS) -> Any:
                  $...BODY
          - pattern: |
              async def $FUNC($...PARAMS) -> Any:
                  $...BODY
    paths:
      include:
        - "**/doeff/"
      exclude:
        - "**/tests/**"
        - "**/_*.py"
    message: |
      Avoid using `Any` in public API signatures. Use specific types or TypeVar
      for proper type safety. If truly dynamic, document why Any is necessary.
    languages: [python]
    severity: WARNING
    metadata:
      category: type-safety

  # ---------------------------------------------------------------------------
  # DOCUMENTATION - DEPRECATED API USAGE PATTERNS
  # ---------------------------------------------------------------------------
  # These rules detect USAGE of deprecated Runtime/Runner classes in docs.
  # The old class-based API was replaced with function-based sync_run/async_run.
  #
  # Excluded paths:
  # - docs/proposals/: Historical proposal documents
  # - docs/20-runtime-scheduler.md: Contains migration guide with "Before" examples

  - id: docs-no-runtime-instantiation
    pattern-regex: '(SyncRuntime|AsyncRuntime|AsyncioRuntime|SimulationRuntime)\s*\('
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: Runtime class instantiation detected.
      Use function-based API:
        sync_run(program, sync_handlers_preset)
        await async_run(program, async_handlers_preset)
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  - id: docs-no-runner-instantiation
    pattern-regex: '(SyncRunner|AsyncRunner)\s*\('
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: Runner class instantiation detected.
      Use function-based API:
        sync_run(program, sync_handlers_preset)
        await async_run(program, async_handlers_preset)
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  - id: docs-no-runtime-run-method
    pattern-regex: 'runtime\.run\s*\('
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: runtime.run() method call detected.
      Use function-based API:
        sync_run(program, sync_handlers_preset)
        await async_run(program, async_handlers_preset)
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  - id: docs-no-runtime-import
    pattern-regex: 'from doeff\.(runtime|runner|runtimes) import'
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: Import from removed runtime/runner modules.
      Use: from doeff import sync_run, async_run, sync_handlers_preset, async_handlers_preset
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  # ---------------------------------------------------------------------------
  # DEPRECATED RUNTIME/INTERPRETER CLASS USAGE (packages & tests)
  # ---------------------------------------------------------------------------
  # The old class-based API (AsyncRuntime, SyncRuntime, ProgramInterpreter)
  # was replaced with function-based run()/async_run()/default_handlers().
  # These rules catch leftover usage AND compatibility shims that fake migration.

  - id: doeff-no-legacy-runtime-usage
    pattern-regex: '(AsyncRuntime|SyncRuntime|ProgramInterpreter)\s*\('
    paths:
      exclude:
        - "**/docs/proposals/**"
        - "**/docs/20-runtime-scheduler.md"
    message: |
      BANNED: Legacy runtime/interpreter instantiation.
      AsyncRuntime, SyncRuntime, and ProgramInterpreter are removed.
      Use the function-based API:
        result = run(program, handlers=default_handlers())
        result = await async_run(program, handlers=default_handlers())
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-runtime
      rationale: "Class-based runtimes are removed; use run()/async_run()"

  - id: doeff-no-legacy-runtime-import
    pattern-regex: 'from\s+doeff\s+import\s+[^#\n]*(AsyncRuntime|SyncRuntime|ProgramInterpreter)'
    paths:
      exclude:
        - "**/docs/proposals/**"
    message: |
      BANNED: Importing removed runtime/interpreter classes.
      AsyncRuntime, SyncRuntime, and ProgramInterpreter no longer exist.
      Use: from doeff import run, async_run, default_handlers
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-runtime
      rationale: "These classes are removed from doeff public API"

  - id: doeff-no-legacy-runtime-class-def
    pattern-regex: 'class\s+(AsyncRuntime|SyncRuntime|ProgramInterpreter)\b'
    message: |
      BANNED: Defining compatibility shim classes for removed runtimes.
      Do not create AsyncRuntime/SyncRuntime/ProgramInterpreter shim classes.
      Migrate call sites to use run()/async_run()/default_handlers() directly.
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-runtime
      rationale: "Shim classes defeat the purpose of migration"

  - id: doeff-no-monkey-patch-module
    pattern-regex: 'doeff\.\w+\s*=\s*'
    paths:
      exclude:
        - "**/doeff/**"
    message: |
      BANNED: Monkey-patching the doeff module from outside.
      Do not inject attributes into the doeff namespace (e.g. doeff.AsyncRuntime = ...).
      Use the official public API as-is.
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-runtime
      rationale: "Monkey-patching masks incomplete migrations"

  # ---------------------------------------------------------------------------
  # DOEFF DOEXPR HIERARCHY ENFORCEMENT
  # ---------------------------------------------------------------------------

  - id: doeff-doexpr-root-boundary-python
    patterns:
      - pattern-inside: |
          def _coerce_program($PROGRAM):
              ...
      - pattern-either:
          - pattern: isinstance($PROGRAM, ($VM.EffectBase, $VM.DoCtrlBase))
          - pattern: isinstance($PROGRAM, ($VM.DoCtrlBase, $VM.EffectBase))
    paths:
      include:
        - "**/doeff/rust_vm.py"
    message: |
      Boundary validation must use unified DoExpr root.
      Use: isinstance(program, vm.DoExpr)
    languages: [python]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "run()/async_run() boundary must validate against single DoExpr root"

  - id: doeff-withhandler-no-program-keyword
    pattern: WithHandler(..., program=$EXPR, ...)
    paths:
      include:
        - "**/doeff/**/*.py"
        - "**/packages/doeff-vm/doeff_vm/**/*.py"
        - "**/tests/public_api/**/*.py"
    message: |
      WithHandler must use `expr=` keyword (or positional expr), not `program=`.
      Use: WithHandler(handler=..., expr=...)
    languages: [python]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "canonical WithHandler signature is (handler, expr: DoExpr)"

  - id: doeff-doexpr-root-check-to-generator-strict
    patterns:
      - pattern-inside: |
          fn to_generator_strict($...ARGS) -> $RET {
              ...
          }
      - pattern-either:
          - pattern: $OBJ.is_instance_of::<PyEffectBase>()
          - pattern: $OBJ.is_instance_of::<PyDoCtrlBase>()
          - pattern: $OBJ.is_instance_of::<PyKPC>()
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      to_generator_strict must classify using unified PyDoExprBase root check.
      Use: obj.is_instance_of::<PyDoExprBase>()
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "single-root DoExpr boundary avoids split classification logic"

  - id: doeff-doexpr-root-check-withhandler-constructor
    patterns:
      - pattern-inside: |
          impl PyWithHandler {
              ...
          }
      - pattern-either:
          - pattern: $OBJ.is_instance_of::<PyEffectBase>()
          - pattern: $OBJ.is_instance_of::<PyDoCtrlBase>()
          - pattern: $OBJ.is_instance_of::<PyKPC>()
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      WithHandler constructor must validate expr via PyDoExprBase root.
      Use: expr_obj.is_instance_of::<PyDoExprBase>()
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "WithHandler expr is DoExpr, not a disjunction of concrete bases"

  - id: doeff-no-yielded-effect-variant
    patterns:
      - pattern: Yielded::Effect($X)
    paths:
      include:
        - "**/packages/doeff-vm/src/**/*.rs"
    message: |
      Perform architecture: direct Yielded::Effect is forbidden.
      Effects must be lifted into DoCtrl::Perform(effect) and handled via DoCtrl path.
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-perform
      rationale: "Dispatch entry must be explicit via DoCtrl::Perform"

  - id: doeff-classify-effect-must-lift-to-perform
    patterns:
      - pattern-inside: |
          fn classify_yielded($...ARGS) -> $RET {
              ...
          }
      - pattern: return Ok(Yielded::Effect($E));
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      classify_yielded must lift effect values to DoCtrl::Perform(effect),
      not return Yielded::Effect.
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-perform
      rationale: "Effect data and dispatch control must be explicitly separated"

  # ---------------------------------------------------------------------------
  # SPEC AUDIT SA-001: GAP ENFORCEMENT RULES
  # ---------------------------------------------------------------------------

  - id: spec-gap-SA-001-G06-marker-attr-effects
    patterns:
      - pattern-either:
          - pattern: has_true_attr($OBJ, "__doeff_state_get__")
          - pattern: has_true_attr($OBJ, "__doeff_state_put__")
          - pattern: has_true_attr($OBJ, "__doeff_state_modify__")
          - pattern: has_true_attr($OBJ, "__doeff_reader_ask__")
          - pattern: has_true_attr($OBJ, "__doeff_writer_tell__")
    message: |
      SA-001-G06: Effect detection via marker attributes.
      Should use isinstance with Rust #[pyclass] types per SPEC-008 R11-A.
    languages: [rust]
    severity: WARNING
    metadata:
      category: spec-audit-SA-001
      gap: G06

  - id: spec-gap-SA-001-G08-classify-duck-typing
    patterns:
      - pattern-either:
          - pattern: $OBJ.getattr(...)
          - pattern: $OBJ.hasattr(...)
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      SA-001-G08: classify_yielded uses duck-typing.
      Should use is_instance_of checks only per SPEC-008 R11-C.
    languages: [rust]
    severity: WARNING
    metadata:
      category: spec-audit-SA-001
      gap: G08

  # ---------------------------------------------------------------------------
  # PUBLIC API LOCATION GUARDS
  # ---------------------------------------------------------------------------

  - id: doeff-no-removed-api
    pattern-regex: 'from\s+doeff\s+import\s+[^#\n]*(wrap_with_handler_map|run_with_handler_map|async_run_with_handler_map|run_program|ProgramRunResult)\b'
    message: |
      This symbol has been removed from the public API.
      - wrap_with_handler_map: internal helper
      - run_with_handler_map / async_run_with_handler_map: use run() + WithHandler
      - run_program / ProgramRunResult: use run()
    languages: [python]
    severity: ERROR
    metadata:
      category: public-api-removed

  - id: doeff-no-safe-use-try
    pattern-regex: '(from\s+doeff[.\w]*\s+import\s+[^#\n]*\bSafe\b|yield\s+Safe\()'
    paths:
      exclude:
        - "**/doeff/effects/result.py"
    message: |
      Safe is renamed to Try. Use:
        from doeff import Try
        result = yield Try(sub_program())
    languages: [python]
    severity: ERROR
    metadata:
      category: public-api-renamed

  - id: doeff-public-api-no-subpackage-imports
    patterns:
      - pattern-either:
          - pattern-regex: '^from\\s+doeff\\.[A-Za-z0-9_.]+\\s+import\\s+'
          - pattern-regex: '^import\\s+doeff\\.[A-Za-z0-9_.]+'
    paths:
      include:
        - "**/tests/public_api/**/*.py"
        - "**/examples/**/*.py"
    message: |
      Subpackage imports are allowed, but top-level imports are preferred.
      Prefer `from doeff import X` when X is available at the top level.
      Use subpackage imports when you need module-specific internals.
    languages: [python]
    severity: WARNING
    metadata:
      category: public-api-location
      rationale: "Top-level import is preferred, but subpackage imports are permitted"

  - id: doeff-public-docs-no-subpackage-imports
    patterns:
      - pattern-regex: 'from\\s+doeff\\.[A-Za-z0-9_.]+\\s+import\\s+'
    paths:
      include:
        - "**/docs/06-io-effects.md"
        - "**/docs/16-run-program-api.md"
    message: |
      Consumer-facing docs must use top-level imports: `from doeff import ...`.
    languages: [generic]
    severity: ERROR
    metadata:
      category: public-api-location
      rationale: "Docs should reflect stable top-level public API"
