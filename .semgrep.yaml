rules:
  # =============================================================================
  # DOEFF ARCHITECTURAL ENFORCEMENT RULES
  # =============================================================================
  # These rules enforce architectural decisions specific to the doeff framework.
  # For code quality patterns (immutability, naming), see doeff-linter (Rust).
  # 
  # Install semgrep: uv tool install semgrep
  # Run: semgrep --config .semgrep.yaml doeff/ packages/
  # =============================================================================

  # ---------------------------------------------------------------------------
  # EFFECT SYSTEM PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-effect-creation-context-wrapper
    patterns:
      - pattern-either:
          - pattern: create_effect_with_trace(...)
          - pattern: capture_creation_context(...)
    paths:
      include:
        - "**/doeff/effects/**"
        - "**/packages/doeff-events/src/**"
        - "**/packages/doeff-time/src/**"
        - "**/doeff/utils.py"
    message: |
      BANNED: EffectCreationContext wrappers are removed (VM-PROTO-006).
      Construct effects directly; source locations come from DoeffGenerator.get_frame
      and VM traceback_data, not effect.created_at metadata.
    languages: [python]
    severity: ERROR
    metadata:
      category: vm-protocol
      issue: VM-PROTO-006

  - id: time-handler-must-not-handle-spawn
    patterns:
      - pattern: |
          if isinstance($EFFECT, SpawnEffect):
              ...
    paths:
      include:
        - "**/packages/doeff-time/**"
    message: >
      Time handlers must not handle SpawnEffect. Concurrency is the core
      scheduler's responsibility. Use Delegate() for Spawn/Wait/Gather/Race.
    severity: ERROR
    languages: [python]
    metadata:
      category: architecture
      violation: handler-boundary

  - id: time-handler-must-not-handle-wait
    patterns:
      - pattern: |
          if isinstance($EFFECT, WaitEffect):
              ...
    paths:
      include:
        - "**/packages/doeff-time/**"
    message: >
      Time handlers must not handle WaitEffect. Concurrency is the core
      scheduler's responsibility. Use Delegate() for Spawn/Wait/Gather/Race.
    severity: ERROR
    languages: [python]
    metadata:
      category: architecture
      violation: handler-boundary

  - id: time-handler-must-not-handle-gather
    patterns:
      - pattern: |
          if isinstance($EFFECT, GatherEffect):
              ...
    paths:
      include:
        - "**/packages/doeff-time/**"
    message: >
      Time handlers must not handle GatherEffect. Concurrency is the core
      scheduler's responsibility. Use Delegate() for Spawn/Wait/Gather/Race.
    severity: ERROR
    languages: [python]
    metadata:
      category: architecture
      violation: handler-boundary

  - id: time-handler-must-not-handle-race
    patterns:
      - pattern: |
          if isinstance($EFFECT, RaceEffect):
              ...
    paths:
      include:
        - "**/packages/doeff-time/**"
    message: >
      Time handlers must not handle RaceEffect. Concurrency is the core
      scheduler's responsibility. Use Delegate() for Spawn/Wait/Gather/Race.
    severity: ERROR
    languages: [python]
    metadata:
      category: architecture
      violation: handler-boundary

  - id: doeff-no-effect-substitution-on-forward
    pattern-either:
      - pattern: yield Delegate($ARG)
      - pattern: yield Pass($ARG)
    message: |
      Delegate() and Pass() do not accept effect arguments.
      Use the 3-step decomposition: yield the substituted effect directly,
      then Resume(k, result).
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      issue: MIGRATE-PASS-005

  - id: doeff-no-python-side-cancel-state
    patterns:
      - pattern-either:
          - pattern: _cancelled_task_ids
          - pattern: _cancelled_task_ids.add(...)
          - pattern: _cancelled_task_ids.discard(...)
          - pattern: $X in _cancelled_task_ids
    paths:
      include:
        - "**/doeff/**"
      exclude:
        - "**/tests/**"
    message: |
      BANNED: Python-side cancel state management.
      Cancellation state belongs in the Rust scheduler (`cancel_requested: HashSet<TaskId>`).
      Task.cancel() must yield a PyCancelEffect, not mutate Python globals.
      See SPEC-SCHED-001 §Cancel, ISSUE-CORE-502.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Cancel state ownership — SPEC-SCHED-001, ISSUE-CORE-502"

  - id: doeff-no-inline-spawn-coercion-wrapper
    pattern: |
      @do
      def $FUNC(...):
          ...
          $RAW = yield $EFFECT
          ...
          return coerce_task_handle($RAW)
    paths:
      include:
        - "**/doeff/effects/spawn.py"
    message: |
      BANNED: Inline SpawnEffect coercion inside @do wrappers.
      spawn()/Spawn() must return SpawnEffect directly and coercion must happen
      in spawn_intercept_handler at the handler layer.
      See VM-HANDLER-METADATA-001.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      issue: VM-HANDLER-METADATA-001

  - id: no-is-instance-from-in-handlers
    pattern: is_instance_from($OBJ, $MODULE, $CLASS)
    message: |
      Use obj.is_instance_of::<RustPyClass>() / extract::<PyRef<RustPyClass>>() instead of
      is_instance_from(). Built-in effects must be Rust PyClasses.
    severity: ERROR
    languages: [rust]
    paths:
      include:
        - "**/packages/doeff-vm/src/handler.rs"
        - "**/packages/doeff-vm/src/scheduler.rs"

  - id: no-python-effect-class-shadowing
    pattern-either:
      - pattern: |
          class StateGetEffect(EffectBase):
              ...
      - pattern: |
          class StatePutEffect(EffectBase):
              ...
      - pattern: |
          class StateModifyEffect(EffectBase):
              ...
      - pattern: |
          class AskEffect(EffectBase):
              ...
      - pattern: |
          class HashableAskEffect(EffectBase):
              ...
      - pattern: |
          class LocalEffect(EffectBase):
              ...
      - pattern: |
          class WriterTellEffect(EffectBase):
              ...
      - pattern: |
          class SpawnEffect(EffectBase):
              ...
      - pattern: |
          class GatherEffect(EffectBase):
              ...
      - pattern: |
          class RaceEffect(EffectBase):
              ...
      - pattern: |
          class CreatePromiseEffect(EffectBase):
              ...
      - pattern: |
          class CompletePromiseEffect(EffectBase):
              ...
      - pattern: |
          class FailPromiseEffect(EffectBase):
              ...
      - pattern: |
          class CreateExternalPromiseEffect(EffectBase):
              ...
      - pattern: |
          class CreateSemaphoreEffect(EffectBase):
              ...
      - pattern: |
          class AcquireSemaphoreEffect(EffectBase):
              ...
      - pattern: |
          class ReleaseSemaphoreEffect(EffectBase):
              ...
      - pattern: |
          class PythonAsyncioAwaitEffect(EffectBase):
              ...
      - pattern: |
          class ResultSafeEffect(EffectBase):
              ...
      - pattern: |
          class ProgramTraceEffect(EffectBase):
              ...
      - pattern: |
          class ProgramCallStackEffect(EffectBase):
              ...
      - pattern: |
          class ProgramCallFrameEffect(EffectBase):
              ...
    message: |
      Built-in effects must be Rust PyClasses imported from doeff_vm, not Python re-implementations.
    severity: ERROR
    languages: [python]
    paths:
      include:
        - "**/doeff/effects/state.py"
        - "**/doeff/effects/reader.py"
        - "**/doeff/effects/writer.py"
        - "**/doeff/effects/spawn.py"
        - "**/doeff/effects/gather.py"
        - "**/doeff/effects/race.py"
        - "**/doeff/effects/promise.py"
        - "**/doeff/effects/external_promise.py"
        - "**/doeff/effects/semaphore.py"
        - "**/doeff/effects/future.py"
        - "**/doeff/effects/result.py"

  # ---------------------------------------------------------------------------
  # VM DECOMPOSITION ENFORCEMENT (VM-DECOMPOSE-002)
  # ---------------------------------------------------------------------------

  - id: vm-decompose-no-impl-vm-outside-vm-rs
    patterns:
      - pattern: |
          impl VM {
              ...
          }
    paths:
      include:
        - "**/packages/doeff-vm/src/**"
      exclude:
        - "**/packages/doeff-vm/src/vm.rs"
    message: |
      BANNED: `impl VM` blocks are only allowed in vm.rs.
      Extracted sub-structs must define methods on their own type
      (e.g., `impl InterceptorState`), not on VM.
      VM orchestrates by calling sub-struct methods, not by owning the logic.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-decomposition
      issue: VM-DECOMPOSE-002
      principle: SRP, composition-over-inheritance

  - id: vm-decompose-no-use-super-wildcard
    pattern: use super::*;
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
        - "**/packages/doeff-vm/src/debug_state.rs"
        - "**/packages/doeff-vm/src/trace_state.rs"
        - "**/packages/doeff-vm/src/interceptor_state.rs"
        - "**/packages/doeff-vm/src/dispatch_state.rs"
    message: |
      BANNED: `use super::*` hides dependencies and defeats decomposition.
      Use explicit imports: `use super::{SpecificType, AnotherType};`
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-decomposition
      issue: VM-DECOMPOSE-002
      principle: explicit-dependencies

  - id: vm-decompose-no-pub-fields-on-substructs
    patterns:
      - pattern-regex: "\\bpub\\s+[A-Za-z_][A-Za-z0-9_]*\\s*:"
      - pattern-not-regex: "\\bpub\\s*\\(\\s*crate\\s*\\)\\s+[A-Za-z_][A-Za-z0-9_]*\\s*:"
    paths:
      include:
        - "**/packages/doeff-vm/src/interceptor_state.rs"
        - "**/packages/doeff-vm/src/dispatch_state.rs"
        - "**/packages/doeff-vm/src/trace_state.rs"
        - "**/packages/doeff-vm/src/debug_state.rs"
    message: |
      BANNED: Sub-struct fields must not be `pub`. Use `pub(crate)` or private
      with accessor methods. Public fields break encapsulation and allow
      bypassing the sub-struct's interface.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-decomposition
      issue: VM-DECOMPOSE-002
      principle: ISP, encapsulation

  - id: doeff-no-python-task-id-extraction
    patterns:
      - pattern-inside: |
          class Task:
              ...
      - pattern: task_id_of(...)
    paths:
      include:
        - "**/doeff/effects/spawn.py"
    message: |
      BANNED: Python code must not extract task_id from Rust handles for scheduler operations.
      Task operations (cancel, is_done) should yield effects handled by the Rust scheduler.
      The Python layer should not inspect or decode Rust-internal handle structures.
      See SPEC-SCHED-001 §PyTask, ISSUE-CORE-502.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Layer boundary — Python must not inspect Rust handle internals"

  - id: doeff-no-rust-poll-python-cancel-state
    pattern-regex: 'getattr\("_cancelled_task_ids"\)'
    paths:
      include:
        - "**/packages/doeff-vm/src/**"
    message: |
      BANNED: Rust scheduler must not poll Python for cancellation state.
      The scheduler owns cancel_requested via PyCancelEffect handler.
      Remove GIL round-trip polling of _cancelled_task_ids.
      See SPEC-SCHED-001, ISSUE-CORE-502.
    languages: [rust]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Scheduler state ownership — cancel state lives in Rust"

  - id: scheduler-must-use-transfer-not-resume
    patterns:
      - pattern: "DoCtrl::Resume { continuation: $K, value: $V }"
      - pattern-not-inside: |
          #[cfg(test)]
          mod tests {
            ...
          }
    paths:
      include:
        - "**/packages/doeff-vm/src/scheduler.rs"
    message: |
      SPEC-SCHED-001 violation: scheduler must tail-switch with DoCtrl::Transfer,
      not DoCtrl::Resume. Scheduler continuation activation must not grow the
      segment chain; use transfer_to_continuation()/throw_to_continuation paths.
      (Test-only match assertions are excluded.)
    languages: [rust]
    severity: ERROR
    metadata:
      spec: SPEC-SCHED-001
      section: "§resume_task, Invariant S1"

  - id: vm-no-segment-ruststore-scope-sync
    pattern-either:
      - pattern: $RUST.scope_bindings = $SEG.scope_store
      - pattern: $RUST.scope_bindings = $SEG.scope_store.clone()
      - pattern: $RUST.scope_bindings = $SEG.scope_store.scope_bindings
      - pattern: $RUST.scope_bindings = $SEG.scope_store.scope_bindings.clone()
      - pattern: $SEG.scope_store = $RUST.scope_bindings
      - pattern: $SEG.scope_store = $RUST.scope_bindings.clone()
      - pattern: $SEG.scope_store.scope_bindings = $RUST.scope_bindings
      - pattern: $SEG.scope_store.scope_bindings = $RUST.scope_bindings.clone()
    paths:
      include:
        - "**/packages/doeff-vm/src/**/*.rs"
    message: |
      CESK architecture violation: scope bindings must not be synchronized
      between RustStore and Segment. Store ownership is single-source-of-truth
      on Segment.scope_store only; remove dual-store sync code.
    languages: [rust]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "CESK store ownership — Segment-only scope store, no dual-store sync"

  - id: doctrl-variants-require-approval
    pattern-regex: '(?ms)pub\s+enum\s+DoCtrl\s*\{(?:(?!^\}).)*^\s*(?!Pure\b|Map\b|FlatMap\b|Perform\b|Resume\b|Transfer\b|TransferThrow\b|ResumeThrow\b|WithHandler\b|Delegate\b|Pass\b|GetContinuation\b|GetHandlers\b|GetTraceback\b|CreateContinuation\b|ResumeContinuation\b|PythonAsyncSyntaxEscape\b|Apply\b|Expand\b|Eval\b|GetCallStack\b|GetTrace\b)[A-Za-z_][A-Za-z0-9_]*\s*(\{|,)'
    paths:
      include:
        - "**/packages/doeff-vm/src/do_ctrl.rs"
    message: |
      DoCtrl is a controlled API. New variants require human approval.
      Do not add variants without discussing with the maintainer first.
    languages: [rust]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "DoCtrl surface area is intentionally fixed and review-gated."

  - id: doeff-cancel-must-be-effectful
    patterns:
      - pattern-inside: |
          class Task:
              ...
      - pattern: |
          def cancel(self):
              ...
              return Program.pure(...)
    paths:
      include:
        - "**/doeff/effects/spawn.py"
    message: |
      BANNED: Task.cancel() must yield an effect, not return Program.pure().
      Cancel is a scheduler operation — it must go through effect dispatch.
      Use: return TaskCancelEffect(task=self)
      See SPEC-SCHED-001 §PyTask, ISSUE-CORE-502.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Cancel must be effectful per SPEC-SCHED-001"

  - id: doeff-no-direct-generator-in-do
    patterns:
      - pattern: |
          @do
          def $FUNC(...):
              ...
              yield from $EXPR
              ...
    paths:
      exclude:
        - "**/tests/**"
    message: |
      Do not use `yield from` in @do functions. Each effect should be yielded individually
      to maintain proper effect tracking and call tree construction.
      Use: `result = yield sub_program()` instead of `yield from sub_program()`.
    languages: [python]
    severity: ERROR
    metadata:
      category: effect-system
      rationale: "yield from bypasses effect tracking and breaks call tree construction"

  - id: doeff-no-async-in-do-function
    pattern-regex: '@do\s*\n\s*async\s+def\s+\w+'
    paths:
      exclude:
        - "**/examples/marker_patterns.py"
    message: |
      @do functions should not be async. The @do decorator handles async execution
      through the effect system. Remove 'async' keyword and use Await effect for
      async operations: `result = yield Await(async_func())`.
    languages: [python]
    severity: ERROR
    metadata:
      category: effect-system
      rationale: "@do functions use generator-based concurrency, not async/await"

  - id: doeff-no-bare-return-in-generator
    patterns:
      - pattern: |
          @do
          def $FUNC(...):
              ...
              return
    message: |
      @do functions should return a value, not bare `return`. If no value is needed,
      use `return None` explicitly for clarity.
    languages: [python]
    severity: WARNING
    metadata:
      category: effect-system

  - id: doeff-to-generator-must-wrap-doeff-generator
    patterns:
      - pattern-inside: |
          def to_generator(...):
              ...
      - pattern: return $RETURN_VALUE
      - pattern-not: return make_doeff_generator(...)
      - pattern-not: return DoeffGenerator(...)
      - pattern-not: return vm.DoeffGenerator(...)
      - pattern-not: return _to_doeff_generator(...)
    paths:
      include:
        - "**/doeff/program.py"
        - "**/packages/doeff-vm/doeff_vm/__init__.py"
    message: |
      VM-PROTO-002: to_generator() construction sites must return DoeffGenerator.
      Wrap generator values with make_doeff_generator(...) (or construct
      DoeffGenerator directly with all required metadata fields).
    languages: [python]
    severity: ERROR
    metadata:
      category: vm-protocol
      issue: VM-PROTO-002

  - id: doeff-no-dunder-inner-chain-walking
    pattern-regex: "__doeff_inner__"
    paths:
      include:
        - "**/doeff/do.py"
    message: |
      VM-PROTO-002 C1: doeff/do.py must not rely on __doeff_inner__ dunder
      chain walking. Use explicit get_frame callbacks (plain gi_frame or
      bridge-local traversal) for DoeffGenerator frame resolution.
    languages: [python]
    severity: ERROR
    metadata:
      category: vm-protocol
      issue: VM-PROTO-002

  - id: doeff-vm-proto-003-no-pymodule-from-code-in-pyvm
    pattern: PyModule::from_code(...)
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      VM-PROTO-003: VM runtime must not synthesize generator wrappers via
      PyModule::from_code. Remove synthetic helpers and rely on Python-side
      to_generator()/WithHandler wrapping that returns DoeffGenerator.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-protocol
      issue: VM-PROTO-003
      rationale: "No synthetic generator helpers in VM core"

  - id: doeff-vm-proto-003-no-runtime-handler-dunder-probing
    patterns:
      - pattern-either:
          - pattern: $OBJ.getattr("__code__")
          - pattern: $OBJ.getattr("__name__")
          - pattern: $OBJ.getattr("__qualname__")
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
    message: |
      VM-PROTO-003: Handler metadata must come from typed Handler::Python
      fields captured at registration time. Runtime __code__/__name__/__qualname__
      probing in vm.rs is forbidden.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-protocol
      issue: VM-PROTO-003
      rationale: "Eliminate runtime handler metadata probing"

  - id: doeff-traceback-except-must-log
    patterns:
      - pattern-inside: |
          def $FUNC(...):
              ...
      - metavariable-regex:
          metavariable: $FUNC
          regex: "^(_build_doeff_traceback_if_present|_print_doeff_trace_if_present)$"
      - pattern-either:
          - pattern: |
              try:
                  ...
              except Exception:
                  ...
          - pattern: |
              try:
                  ...
              except Exception as $ERR:
                  ...
      - pattern-not: |
          try:
              ...
          except Exception:
              ...
              warnings.warn(...)
              ...
      - pattern-not: |
          try:
              ...
          except Exception as $ERR:
              ...
              warnings.warn(...)
              ...
      - pattern-not: |
          try:
              ...
          except Exception:
              ...
              logging.warning(...)
              ...
      - pattern-not: |
          try:
              ...
          except Exception as $ERR:
              ...
              logging.warning(...)
              ...
    paths:
      include:
        - "**/doeff/rust_vm.py"
    message: |
      Traceback-layer exception handlers must log before graceful degradation.
      Add warnings.warn(...) or logging.warning(...) inside except Exception blocks.
    languages: [python]
    severity: ERROR
    metadata:
      category: traceback-invariant
      issue: VM-FAILFAST-001C

  - id: no-silent-except-in-traceback
    patterns:
      - pattern: |
          try:
              ...
          except Exception:
              return ...
    message: "FAILFAST: Do not silently swallow exceptions. Add warnings.warn() or logging before return."
    languages: [python]
    paths:
      include:
        - "**/doeff/rust_vm.py"
        - "**/doeff/traceback.py"
        - "**/doeff/trace.py"
    severity: ERROR
    metadata:
      spec: VM-FAILFAST-001C
      category: fail-fast

  - id: no-silent-except-return-none
    patterns:
      - pattern: |
          try:
              ...
          except Exception:
              return None
    message: "FAILFAST: Do not silently return None on exception. Add warnings.warn() or re-raise."
    languages: [python]
    paths:
      include:
        - "**/doeff/*.py"
      exclude:
        - "**/doeff/test_*.py"
        - "**/doeff/*_test.py"
    severity: WARNING
    metadata:
      spec: VM-FAILFAST-001C
      category: fail-fast

  # ---------------------------------------------------------------------------
  # LAYER BOUNDARIES
  # ---------------------------------------------------------------------------

  - id: doeff-no-handler-import-in-effects
    patterns:
      - pattern-inside: |
          # In doeff/effects/ directory
          ...
      - pattern-either:
          - pattern: from doeff.handlers import $X
          - pattern: from doeff.handlers.$MOD import $X
          - pattern: import doeff.handlers
    paths:
      include:
        - "**/doeff/effects/"
    message: |
      Effects should not import from handlers. This violates layer separation.
      Effects define WHAT operations are available; handlers define HOW to execute them.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Effects layer must not depend on handlers layer"

  - id: doeff-no-runtime-import-in-effects
    patterns:
      - pattern-either:
          - pattern: from doeff.runtimes import $X
          - pattern: from doeff.interpreter import $X
          - pattern: import doeff.runtimes
    paths:
      include:
        - "**/doeff/effects/"
    message: |
      Effects should not import from runtimes or interpreter. This violates layer separation.
      Effects are pure data structures describing operations.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture

  - id: doeff-no-handler-modification-in-run
    patterns:
      - pattern-either:
          - pattern: _normalize_async_handlers(...)
          - pattern: _needs_threaded_async_driver(...)
    paths:
      include:
        - "**/doeff/"
    message: |
      Handler lists must never be modified by run() or async_run().
      Handler selection is the user's responsibility. Remove handler
      normalization/detection functions.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Handler immutability invariant — SPEC-EFF-011, ISSUE-CORE-495"

  - id: doeff-no-thread-offload-in-async-run
    patterns:
      - pattern: asyncio.to_thread(...)
    paths:
      include:
        - "**/doeff/rust_vm.py"
    message: |
      async_run must not offload VM stepping to a background thread.
      The VM step loop should run on the caller's event loop.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "VM boundary invariant — SPEC-EFF-011, ISSUE-CORE-495"

  # ---------------------------------------------------------------------------
  # PURITY PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-print-in-core
    patterns:
      - pattern: print(...)
    paths:
      include:
        - "**/doeff/"
      exclude:
        - "**/doeff/__main__.py"
        - "**/doeff/cli/"
        - "**/tests/**"
        - "**/examples/**"
    message: |
      Do not use print() in core library code. Use the Log effect for logging:
      `yield Log("message")` or configure loguru for internal debugging.
    languages: [python]
    severity: WARNING
    metadata:
      category: purity

  - id: doeff-no-datetime-now-in-do
    patterns:
      - pattern-inside: |
          @do
          def $FUNC(...):
              ...
      - pattern-either:
          - pattern: datetime.now(...)
          - pattern: datetime.datetime.now(...)
          - pattern: datetime.utcnow(...)
          - pattern: datetime.datetime.utcnow(...)
    message: |
      Do not call datetime.now() directly in @do functions. This makes the function
      impure and hard to test. Use the GetTime effect instead:
      `current_time = yield GetTime()`.
    languages: [python]
    severity: WARNING
    metadata:
      category: purity

  - id: doeff-no-random-in-do
    patterns:
      - pattern-inside: |
          @do
          def $FUNC(...):
              ...
      - pattern-either:
          - pattern: random.random(...)
          - pattern: random.randint(...)
          - pattern: random.choice(...)
          - pattern: random.shuffle(...)
    message: |
      Do not use random module directly in @do functions. This makes the function
      impure. Consider wrapping in an IO effect or injecting via Ask.
    languages: [python]
    severity: WARNING
    metadata:
      category: purity

  # ---------------------------------------------------------------------------
  # DEPENDENCY INJECTION PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-hardcoded-instantiation-in-do
    patterns:
      - pattern-inside: |
          @do
          def $FUNC(...):
              ...
      - pattern-either:
          - pattern: $CLIENT = httpx.Client(...)
          - pattern: $CLIENT = httpx.AsyncClient(...)
          - pattern: $CONN = sqlite3.connect(...)
          - pattern: $ENGINE = create_engine(...)
    message: |
      Do not instantiate clients/connections directly in @do functions. 
      Use dependency injection via the Ask effect:
      `client = yield Ask("http_client")`.
    languages: [python]
    severity: WARNING
    metadata:
      category: dependency-injection

  # ---------------------------------------------------------------------------
  # CONCURRENCY API MIGRATION (SPEC-EFF-005 Redesign)
  # ---------------------------------------------------------------------------
  # These rules detect old concurrency patterns that need migration to the new
  # Future-based API. See specs/effects/SPEC-EFF-005-concurrency.md.

  - id: doeff-task-join-deprecated
    pattern: yield $TASK.join()
    message: |
      MIGRATION: task.join() is deprecated. Use Wait(task) instead.

      OLD: result = yield task.join()
      NEW: result = yield Wait(task)

      See SPEC-EFF-005 for details.
    languages: [python]
    severity: WARNING
    metadata:
      category: concurrency-migration
      spec: SPEC-EFF-005

  # ---------------------------------------------------------------------------
  # DEPRECATED EFFECT NAMES
  # ---------------------------------------------------------------------------

  - id: doeff-no-future-await-effect
    patterns:
      - pattern-either:
          - pattern: FutureAwaitEffect
          - pattern: from doeff.effects.future import FutureAwaitEffect
          - pattern: from doeff.effects import FutureAwaitEffect
    paths:
      exclude:
        # Allow in the definition file where the alias is defined
        - "**/doeff/effects/future.py"
        - "**/doeff/effects/__init__.py"
    message: |
      DEPRECATED: FutureAwaitEffect is renamed to PythonAsyncioAwaitEffect.

      This effect is specifically for Python asyncio awaitables, not a generic
      "future" abstraction. Use the new name for clarity:

      OLD: from doeff.effects import FutureAwaitEffect
      NEW: from doeff.effects import PythonAsyncioAwaitEffect

      Or just use the public API: yield Await(coroutine)
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-names
      rationale: "FutureAwaitEffect is misleading - it's Python asyncio specific"

  # ---------------------------------------------------------------------------
  # TESTING PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-sleep-in-tests
    patterns:
      - pattern-either:
          - pattern: time.sleep(...)
          - pattern: await asyncio.sleep(...)
    paths:
      include:
        - tests/
    message: |
      Avoid time.sleep() or asyncio.sleep() in tests. Use SimulationRuntime
      with controlled time for deterministic testing.
    languages: [python]
    severity: WARNING
    metadata:
      category: testing

  # ---------------------------------------------------------------------------
  # IMPORT HYGIENE
  # ---------------------------------------------------------------------------

  - id: doeff-no-star-imports
    patterns:
      - pattern: from $MODULE import *
    paths:
      exclude:
        - "**/__init__.py"
    message: |
      Do not use star imports (from x import *). Import specific names
      for clarity and to avoid namespace pollution.
    languages: [python]
    severity: WARNING
    metadata:
      category: imports

  - id: doeff-no-typing-any-in-public-api
    patterns:
      - pattern-either:
          - pattern: |
              def $FUNC($...PARAMS) -> Any:
                  $...BODY
          - pattern: |
              async def $FUNC($...PARAMS) -> Any:
                  $...BODY
    paths:
      include:
        - "**/doeff/"
      exclude:
        - "**/tests/**"
        - "**/_*.py"
    message: |
      Avoid using `Any` in public API signatures. Use specific types or TypeVar
      for proper type safety. If truly dynamic, document why Any is necessary.
    languages: [python]
    severity: WARNING
    metadata:
      category: type-safety

  # ---------------------------------------------------------------------------
  # DOCUMENTATION - DEPRECATED API USAGE PATTERNS
  # ---------------------------------------------------------------------------
  # These rules detect USAGE of deprecated Runtime/Runner classes in docs.
  # The old class-based API was replaced with function-based sync_run/async_run.
  #
  # Excluded paths:
  # - docs/proposals/: Historical proposal documents
  # - docs/20-runtime-scheduler.md: Contains migration guide with "Before" examples

  - id: docs-no-runtime-instantiation
    pattern-regex: '(SyncRuntime|AsyncRuntime|AsyncioRuntime|SimulationRuntime)\s*\('
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: Runtime class instantiation detected.
      Use function-based API:
        sync_run(program, sync_handlers_preset)
        await async_run(program, async_handlers_preset)
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  - id: docs-no-runner-instantiation
    pattern-regex: '(SyncRunner|AsyncRunner)\s*\('
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: Runner class instantiation detected.
      Use function-based API:
        sync_run(program, sync_handlers_preset)
        await async_run(program, async_handlers_preset)
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  - id: docs-no-runtime-run-method
    pattern-regex: 'runtime\.run\s*\('
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: runtime.run() method call detected.
      Use function-based API:
        sync_run(program, sync_handlers_preset)
        await async_run(program, async_handlers_preset)
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  - id: docs-no-runtime-import
    pattern-regex: 'from doeff\.(runtime|runner|runtimes) import'
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: Import from removed runtime/runner modules.
      Use: from doeff import sync_run, async_run, sync_handlers_preset, async_handlers_preset
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  # ---------------------------------------------------------------------------
  # DEPRECATED RUNTIME/INTERPRETER CLASS USAGE (packages & tests)
  # ---------------------------------------------------------------------------
  # The old class-based API (AsyncRuntime, SyncRuntime, ProgramInterpreter)
  # was replaced with function-based run()/async_run()/default_handlers().
  # These rules catch leftover usage AND compatibility shims that fake migration.

  - id: doeff-no-legacy-runtime-usage
    pattern-regex: '(AsyncRuntime|SyncRuntime|ProgramInterpreter)\s*\('
    paths:
      exclude:
        - "**/docs/proposals/**"
        - "**/docs/20-runtime-scheduler.md"
    message: |
      BANNED: Legacy runtime/interpreter instantiation.
      AsyncRuntime, SyncRuntime, and ProgramInterpreter are removed.
      Use the function-based API:
        result = run(program, handlers=default_handlers())
        result = await async_run(program, handlers=default_handlers())
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-runtime
      rationale: "Class-based runtimes are removed; use run()/async_run()"

  - id: doeff-no-legacy-runtime-import
    pattern-regex: 'from\s+doeff\s+import\s+[^#\n]*(AsyncRuntime|SyncRuntime|ProgramInterpreter)'
    paths:
      exclude:
        - "**/docs/proposals/**"
    message: |
      BANNED: Importing removed runtime/interpreter classes.
      AsyncRuntime, SyncRuntime, and ProgramInterpreter no longer exist.
      Use: from doeff import run, async_run, default_handlers
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-runtime
      rationale: "These classes are removed from doeff public API"

  - id: doeff-no-legacy-runtime-class-def
    pattern-regex: 'class\s+(AsyncRuntime|SyncRuntime|ProgramInterpreter)\b'
    message: |
      BANNED: Defining compatibility shim classes for removed runtimes.
      Do not create AsyncRuntime/SyncRuntime/ProgramInterpreter shim classes.
      Migrate call sites to use run()/async_run()/default_handlers() directly.
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-runtime
      rationale: "Shim classes defeat the purpose of migration"

  - id: doeff-no-monkey-patch-module
    pattern-regex: 'doeff\.\w+\s*=\s*'
    paths:
      exclude:
        - "**/doeff/**"
    message: |
      BANNED: Monkey-patching the doeff module from outside.
      Do not inject attributes into the doeff namespace (e.g. doeff.AsyncRuntime = ...).
      Use the official public API as-is.
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-runtime
      rationale: "Monkey-patching masks incomplete migrations"

  # ---------------------------------------------------------------------------
  # TRACEBACK DEFAULT FORMAT
  # ---------------------------------------------------------------------------

  - id: traceback-must-use-format-default
    patterns:
      - pattern-inside: |
          def _print_doeff_trace_if_present(...):
              ...
      - pattern-either:
          - pattern: print($TB.format_chained(), file=sys.stderr)
          - pattern: print($TB.format_sectioned(), file=sys.stderr)
          - pattern: print($TB.format_short(), file=sys.stderr)
    paths:
      include:
        - "**/doeff/rust_vm.py"
    message: |
      Default stderr traceback output must use format_default().
      format_chained() remains available for explicit debug views, but the
      default print path must render the active-chain format.
    languages: [python]
    severity: ERROR
    metadata:
      category: traceback
      spec: SPEC-TRACE-001
      rationale: "SPEC-TRACE-001 default format requirement"

  # ---------------------------------------------------------------------------
  # DOEFF DOEXPR HIERARCHY ENFORCEMENT
  # ---------------------------------------------------------------------------

  - id: doeff-doexpr-root-boundary-python
    patterns:
      - pattern-inside: |
          def _coerce_program($PROGRAM):
              ...
      - pattern-either:
          - pattern: isinstance($PROGRAM, ($VM.EffectBase, $VM.DoCtrlBase))
          - pattern: isinstance($PROGRAM, ($VM.DoCtrlBase, $VM.EffectBase))
    paths:
      include:
        - "**/doeff/rust_vm.py"
    message: |
      Boundary validation must use unified DoExpr root.
      Use: isinstance(program, vm.DoExpr)
    languages: [python]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "run()/async_run() boundary must validate against single DoExpr root"

  - id: doeff-withhandler-no-program-keyword
    pattern: WithHandler(..., program=$EXPR, ...)
    paths:
      include:
        - "**/doeff/**/*.py"
        - "**/packages/doeff-vm/doeff_vm/**/*.py"
        - "**/tests/public_api/**/*.py"
    message: |
      WithHandler must use `expr=` keyword (or positional expr), not `program=`.
      Use: WithHandler(handler=..., expr=...)
    languages: [python]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "canonical WithHandler signature is (handler, expr: DoExpr)"

  - id: doeff-doexpr-root-check-to-generator-strict
    patterns:
      - pattern-inside: |
          fn to_generator_strict($...ARGS) -> $RET {
              ...
          }
      - pattern-either:
          - pattern: $OBJ.is_instance_of::<PyEffectBase>()
          - pattern: $OBJ.is_instance_of::<PyDoCtrlBase>()
          - pattern: $OBJ.is_instance_of::<PyKPC>()
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      to_generator_strict must classify using unified PyDoExprBase root check.
      Use: obj.is_instance_of::<PyDoExprBase>()
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "single-root DoExpr boundary avoids split classification logic"

  - id: doeff-doexpr-root-check-withhandler-constructor
    patterns:
      - pattern-inside: |
          impl PyWithHandler {
              ...
          }
      - pattern-either:
          - pattern: $OBJ.is_instance_of::<PyEffectBase>()
          - pattern: $OBJ.is_instance_of::<PyDoCtrlBase>()
          - pattern: $OBJ.is_instance_of::<PyKPC>()
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      WithHandler constructor must validate expr via PyDoExprBase root.
      Use: expr_obj.is_instance_of::<PyDoExprBase>()
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "WithHandler expr is DoExpr, not a disjunction of concrete bases"

  - id: doeff-no-yielded-effect-variant
    patterns:
      - pattern: Yielded::Effect($X)
    paths:
      include:
        - "**/packages/doeff-vm/src/**/*.rs"
    message: |
      Perform architecture: direct Yielded::Effect is forbidden.
      Effects must be lifted into DoCtrl::Perform(effect) and handled via DoCtrl path.
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-perform
      rationale: "Dispatch entry must be explicit via DoCtrl::Perform"

  - id: doeff-classify-effect-must-lift-to-perform
    patterns:
      - pattern-inside: |
          fn classify_yielded($...ARGS) -> $RET {
              ...
          }
      - pattern: return Ok(Yielded::Effect($E));
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      classify_yielded must lift effect values to DoCtrl::Perform(effect),
      not return Yielded::Effect.
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-perform
      rationale: "Effect data and dispatch control must be explicitly separated"

  - id: doeff-vm-handle-map-no-anonymous-callmetadata
    patterns:
      - pattern-inside: |
          fn handle_map(...) {
              ...
          }
      - pattern-either:
          - pattern: CallMetadata::anonymous()
          - pattern: crate::frame::CallMetadata::anonymous()
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
    message: |
      VM-PROTO-005: Map callback calls must carry explicit callback metadata.
      Do not use CallMetadata::anonymous() in handle_map runtime paths.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-protocol
      rationale: "SPEC-VM-PROTOCOL §5.5 and §2 C7 require explicit callback metadata"

  - id: doeff-vm-handle-flat-map-no-anonymous-callmetadata
    patterns:
      - pattern-inside: |
          fn handle_flat_map(...) {
              ...
          }
      - pattern-either:
          - pattern: CallMetadata::anonymous()
          - pattern: crate::frame::CallMetadata::anonymous()
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
    message: |
      VM-PROTO-005: FlatMap callback calls must carry explicit callback metadata.
      Do not use CallMetadata::anonymous() in handle_flat_map runtime paths.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-protocol
      rationale: "SPEC-VM-PROTOCOL §5.5 and §2 C7 require explicit callback metadata"

  - id: doeff-no-direct-gi-frame-access
    patterns:
      - pattern-either:
          - pattern: $OBJ.getattr("gi_frame")
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      Direct gi_frame access in VM Rust code is banned by SPEC-VM-PROTOCOL.
      Use DoeffGenerator.get_frame(generator) callback and handle None/exception
      semantics through the protocol diagnostics path.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-protocol
      rationale: "SPEC-VM-PROTOCOL §3.2/§3.7 requires callback-based frame lookup"

  # ---------------------------------------------------------------------------
  # C9 CLEANUP ENFORCEMENT
  # ---------------------------------------------------------------------------

  - id: vm-no-runtime-type-branching
    pattern-either:
      - pattern: is_doeff_generator_object(...)
      - pattern: is_generator_object(...)
    message: |
      C9: Runtime type branching helpers are removed.
      Use the unified DoExpr/ASTStream protocol path instead.
    languages: [rust]
    severity: ERROR

  - id: vm-no-handler-type-dispatch
    pattern-regex: 'Handler::Python\\s*\\{'
    message: |
      C9: Handler enum type switching is removed.
      Dispatch must flow through HandlerInvoke trait objects.
    languages: [rust]
    severity: ERROR

  - id: no-getattr-in-classify-yielded
    patterns:
      - pattern-inside: |
          fn classify_yielded($...ARGS) -> $RET {
              ...
          }
      - pattern: $OBJ.getattr($ATTR)
    message: |
      classify_yielded must avoid getattr-based branching.
      Use tag-based or typed extraction paths only.
    languages: [rust]
    severity: ERROR
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"

  - id: no-is-instance-from-in-pyvm
    pattern: is_instance_from(...)
    message: |
      is_instance_from is forbidden in pyvm.rs.
      Use typed extraction / instance checks against Rust pyclasses.
    languages: [rust]
    severity: ERROR
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"

  # ---------------------------------------------------------------------------
  # SPEC AUDIT SA-001: GAP ENFORCEMENT RULES
  # ---------------------------------------------------------------------------

  - id: spec-gap-SA-001-G06-marker-attr-effects
    patterns:
      - pattern-either:
          - pattern: has_true_attr($OBJ, "__doeff_state_get__")
          - pattern: has_true_attr($OBJ, "__doeff_state_put__")
          - pattern: has_true_attr($OBJ, "__doeff_state_modify__")
          - pattern: has_true_attr($OBJ, "__doeff_reader_ask__")
          - pattern: has_true_attr($OBJ, "__doeff_writer_tell__")
    message: |
      SA-001-G06: Effect detection via marker attributes.
      Should use isinstance with Rust #[pyclass] types per SPEC-008 R11-A.
    languages: [rust]
    severity: WARNING
    metadata:
      category: spec-audit-SA-001
      gap: G06

  - id: spec-gap-SA-001-G08-classify-duck-typing
    patterns:
      - pattern-either:
          - pattern: $OBJ.getattr(...)
          - pattern: $OBJ.hasattr(...)
      - pattern-not-inside: |
          #[cfg(test)]
          mod tests {
              ...
          }
      - pattern-not-inside: |
          fn format_traceback_data_preview($...ARGS) -> String {
              ...
          }
      - pattern-not-inside: |
          fn extract_stop_iteration_value($...ARGS) {
              ...
          }
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      SA-001-G08: classify_yielded uses duck-typing.
      Should use is_instance_of checks only per SPEC-008 R11-C.
    languages: [rust]
    severity: WARNING
    metadata:
      category: spec-audit-SA-001
      gap: G08

  # ---------------------------------------------------------------------------
  # VM PROTOCOL: FINAL C1/C6 ENFORCEMENT (VM-PROTO-007)
  # ---------------------------------------------------------------------------

  - id: vm-no-dunder-attrs
    patterns:
      - pattern: $OBJ.setattr($ATTR, ...)
      - metavariable-regex:
          metavariable: $ATTR
          regex: '^"__doeff_[A-Za-z0-9_]+__"$'
    message: "VM must not set __doeff_* attributes. Use typed PyClass fields."
    languages: [rust]
    severity: ERROR
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
        - "**/packages/doeff-vm/src/pyvm.rs"
    metadata:
      category: vm-protocol
      issue: VM-PROTO-007

  - id: vm-no-dunder-reads
    patterns:
      - pattern: $OBJ.getattr($ATTR)
      - metavariable-regex:
          metavariable: $ATTR
          regex: '^"__doeff_[A-Za-z0-9_]+__"$'
    message: "VM must not read __doeff_* attributes. Use typed PyClass fields."
    languages: [rust]
    severity: ERROR
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
        - "**/packages/doeff-vm/src/pyvm.rs"
    metadata:
      category: vm-protocol
      issue: VM-PROTO-007

  - id: vm-no-hasattr-dunder
    patterns:
      - pattern: $OBJ.hasattr($ATTR)
      - metavariable-regex:
          metavariable: $ATTR
          regex: '^"__doeff_[A-Za-z0-9_]+__"$'
    message: "VM must not probe __doeff_* attributes. Use isinstance on typed PyClass."
    languages: [rust]
    severity: ERROR
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
        - "**/packages/doeff-vm/src/pyvm.rs"
    metadata:
      category: vm-protocol
      issue: VM-PROTO-007

  - id: vm-no-python-imports
    pattern-regex: '\.import\("doeff\.[A-Za-z0-9_\.]+"\)'
    message: "VM core must not import doeff.* modules. Use typed PyClass or NeedsPython callback."
    languages: [rust]
    severity: ERROR
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
        - "**/packages/doeff-vm/src/pyvm.rs"
    metadata:
      category: vm-protocol
      issue: VM-PROTO-007

  # ---------------------------------------------------------------------------
  # SPEC-VM-014 ENFORCEMENT
  # ---------------------------------------------------------------------------

  - id: vm-no-py-import-in-value-traceback
    pattern-regex: '\.import\("doeff_vm"\)'
    paths:
      include:
        - "**/packages/doeff-vm/src/value.rs"
    message: |
      Value::Traceback conversion must use direct Py::new(py, PyTraceFrame { ... }) construction.
      Do not import doeff_vm module from value.rs - PyTraceFrame and PyTraceHop are in the same crate.
      Use: use crate::pyvm::{PyTraceFrame, PyTraceHop};
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-protocol
      spec: SPEC-VM-014

  - id: vm-no-get-yield-site-artifacts
    pattern-regex: 'GetYieldSite|YieldSite'
    paths:
      include:
        - "**/packages/doeff-vm/src/**"
    message: |
      GetYieldSite/YieldSite are replaced by GetTraceback/Traceback (SPEC-VM-014).
      These artifacts must not exist in VM source.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-protocol
      spec: SPEC-VM-014

  - id: vm-no-spawn-site-on-py-spawn
    pattern-regex: 'spawn_site.*Option<Py<PyAny>>'
    paths:
      include:
        - "**/packages/doeff-vm/src/effect.rs"
    message: |
      PySpawn must not carry spawn_site field. Spawn site attribution uses
      GetTraceback DoCtrl via the scheduler (SPEC-VM-014 Phase 2).
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-protocol
      spec: SPEC-VM-014

  # ---------------------------------------------------------------------------
  # PUBLIC API LOCATION GUARDS
  # ---------------------------------------------------------------------------

  - id: doeff-no-removed-api
    pattern-regex: 'from\s+doeff\s+import\s+[^#\n]*(wrap_with_handler_map|run_with_handler_map|async_run_with_handler_map|run_program|ProgramRunResult)\b'
    message: |
      This symbol has been removed from the public API.
      - wrap_with_handler_map: internal helper
      - run_with_handler_map / async_run_with_handler_map: use run() + WithHandler
      - run_program / ProgramRunResult: use run()
    languages: [python]
    severity: ERROR
    metadata:
      category: public-api-removed

  - id: doeff-no-handler-map-run-helpers
    pattern-regex: '\b(run_with_handler_map|async_run_with_handler_map|_wrap_with_handler_map|merge_handler_maps)\b'
    paths:
      include:
        - "**/doeff/**/*.py"
        - "**/packages/**/src/**/*.py"
        - "**/packages/**/examples/**/*.py"
        - "**/tests/**/*.py"
    message: |
      handler_map bridging APIs are removed.
      Use explicit WithHandler stacking:
        program = WithHandler(handler, program)
        result = run(program, handlers=default_handlers())
    languages: [python]
    severity: ERROR
    metadata:
      category: handler-stacking
      issue: ISSUE-HANDLER-MAP-001

  - id: doeff-no-handler-map-param-annotation
    pattern-regex: 'def\s+\w+\([^)]*\bhandler_map\s*:\s*dict\[type'
    paths:
      include:
        - "**/doeff/**/*.py"
        - "**/packages/**/src/**/*.py"
    message: |
      Type-keyed handler_map annotations are banned.
      Accept a protocol handler callable and stack with WithHandler instead.
    languages: [python]
    severity: ERROR
    metadata:
      category: handler-stacking
      issue: ISSUE-HANDLER-MAP-001

  - id: doeff-no-handler-factory-dict-return
    pattern-regex: 'def\s+(production_handlers|mock_handlers|[A-Za-z0-9_]*handlers)\s*\([^)]*\)\s*->\s*dict\[type'
    paths:
      include:
        - "**/doeff/**/*.py"
        - "**/packages/**/src/**/*.py"
    message: |
      Handler factories must return a protocol handler callable, not dict[type, handler].
      Compose handlers by WithHandler stacking.
    languages: [python]
    severity: ERROR
    metadata:
      category: handler-stacking
      issue: ISSUE-HANDLER-MAP-001

  - id: doeff-no-effect-keyed-handler-dict-literal
    patterns:
      - pattern-either:
          - pattern: |
              return {
                $EFFECT: $HANDLER,
                ...
              }
          - pattern: |
              $HANDLERS = {
                $EFFECT: $HANDLER,
                ...
              }
      - metavariable-regex:
          metavariable: $EFFECT
          regex: '^[A-Z][A-Za-z0-9_]*$'
    paths:
      include:
        - "**/doeff/**/*.py"
        - "**/packages/**/src/**/handlers/**/*.py"
    message: |
      Type-keyed handler dict literals are banned.
      Build a single protocol handler with isinstance(...) checks and Delegate/Pass forwarding.
    languages: [python]
    severity: ERROR
    metadata:
      category: handler-stacking
      issue: ISSUE-HANDLER-MAP-001

  - id: doeff-no-safe-use-try
    pattern-regex: '(from\s+doeff[.\w]*\s+import\s+[^#\n]*\bSafe\b|yield\s+Safe\()'
    paths:
      exclude:
        - "**/doeff/effects/result.py"
    message: |
      Safe is renamed to Try. Use:
        from doeff import Try
        result = yield Try(sub_program())
    languages: [python]
    severity: ERROR
    metadata:
      category: public-api-renamed

  - id: doeff-public-api-no-subpackage-imports
    patterns:
      - pattern-either:
          - pattern-regex: '^from\\s+doeff\\.[A-Za-z0-9_.]+\\s+import\\s+'
          - pattern-regex: '^import\\s+doeff\\.[A-Za-z0-9_.]+'
    paths:
      include:
        - "**/tests/public_api/**/*.py"
        - "**/examples/**/*.py"
    message: |
      Subpackage imports are allowed, but top-level imports are preferred.
      Prefer `from doeff import X` when X is available at the top level.
      Use subpackage imports when you need module-specific internals.
    languages: [python]
    severity: WARNING
    metadata:
      category: public-api-location
      rationale: "Top-level import is preferred, but subpackage imports are permitted"

  - id: doeff-public-docs-no-subpackage-imports
    patterns:
      - pattern-regex: 'from\\s+doeff\\.[A-Za-z0-9_.]+\\s+import\\s+'
    paths:
      include:
        - "**/docs/06-io-effects.md"
        - "**/docs/16-run-program-api.md"
    message: |
      Consumer-facing docs must use top-level imports: `from doeff import ...`.
    languages: [generic]
    severity: ERROR
    metadata:
      category: public-api-location
      rationale: "Docs should reflect stable top-level public API"

  # ---------------------------------------------------------------------------
  # SPEC-VM-015: SEGMENT-OWNED EXECUTION STATE ENFORCEMENT
  # ---------------------------------------------------------------------------
  # These rules enforce that execution-local state lives on Segment, not on
  # VM or InterceptorState. They prevent regression after the structural
  # migration (VM-SCOPE-STRUCTURAL).
  #
  # Theoretical backing: CEK/CESK machines, Hillerström's ⟨C,E,H⟩ model,
  # OCaml fibers, libmprompt gstacks. See SPEC-VM-015 §3.
  #
  # The type system enforces access patterns (self.mode won't compile if mode
  # is not on VM), but these rules prevent someone from ADDING the fields back
  # to the wrong struct.

  - id: vm-scope-no-mode-on-vm-struct
    pattern-regex: 'pub\s+mode\s*:\s*Mode'
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
    message: |
      SPEC-VM-015 INV-1: `mode` must live on Segment, not VM.
      The instruction register is execution-local state owned by the current
      segment. Access via self.current_seg().mode / self.current_seg_mut().mode.
      See SPEC-VM-015 §4.1 (target Segment definition) and §6 (invariants).
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-scope-structural
      spec: SPEC-VM-015
      invariant: INV-1

  - id: vm-scope-no-pending-python-on-vm-struct
    pattern-regex: 'pub\s+pending_python\s*:\s*Option<PendingPython>'
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
    message: |
      SPEC-VM-015 INV-1: `pending_python` must live on Segment, not VM.
      Each execution context tracks its own outstanding Python call.
      See SPEC-VM-015 §4.1 and VM-SCOPE-004 (corruption via overwrite).
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-scope-structural
      spec: SPEC-VM-015
      invariant: INV-1

  - id: vm-scope-no-pending-error-context-on-vm-struct
    pattern-regex: 'pub\s+pending_error_context\s*:\s*Option<PyException>'
    paths:
      include:
        - "**/packages/doeff-vm/src/vm.rs"
    message: |
      SPEC-VM-015 INV-1: `pending_error_context` must live on Segment, not VM.
      Each execution context owns its error context, preventing .take() theft.
      See SPEC-VM-015 §4.1 and VM-SCOPE-003 (stolen by nested .take()).
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-scope-structural
      spec: SPEC-VM-015
      invariant: INV-1

  - id: vm-scope-no-eval-depth-on-interceptor-state
    pattern-regex: 'interceptor_eval_depth\s*:\s*usize'
    paths:
      include:
        - "**/packages/doeff-vm/src/interceptor_state.rs"
    message: |
      SPEC-VM-015 INV-1: `interceptor_eval_depth` must live on Segment, not InterceptorState.
      Interceptor eval depth is execution-local — outer depth must not leak into inner dispatch.
      See SPEC-VM-015 §4.3 and VM-SCOPE-005 (depth leaks across dispatch).
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-scope-structural
      spec: SPEC-VM-015
      invariant: INV-1

  - id: vm-scope-no-skip-stack-on-interceptor-state
    pattern-regex: 'interceptor_skip_stack\s*:\s*Vec<Marker>'
    paths:
      include:
        - "**/packages/doeff-vm/src/interceptor_state.rs"
    message: |
      SPEC-VM-015 INV-1: `interceptor_skip_stack` must live on Segment, not InterceptorState.
      Skip markers are execution-local — inner dispatch skips must not leak to outer.
      See SPEC-VM-015 §4.3 and VM-SCOPE-006 (marker leak across dispatch).
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-scope-structural
      spec: SPEC-VM-015
      invariant: INV-1

  - id: vm-scope-no-saved-mode-on-dispatch-context
    pattern-regex: 'saved_mode\s*:\s*Mode'
    paths:
      include:
        - "**/packages/doeff-vm/src/dispatch.rs"
    message: |
      SPEC-VM-015: Save/restore on DispatchContext is the REJECTED approach.
      With segment-owned state, there is nothing to save or restore.
      DispatchContext must not carry saved_mode. See SPEC-VM-015 §1.3 and §4.4.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-scope-structural
      spec: SPEC-VM-015
      rejected-approach: save-restore

  - id: vm-scope-no-saved-segment-on-dispatch-context
    pattern-regex: 'saved_segment\s*:\s*Option<SegmentId>'
    paths:
      include:
        - "**/packages/doeff-vm/src/dispatch.rs"
    message: |
      SPEC-VM-015: Save/restore on DispatchContext is the REJECTED approach.
      With segment-owned state, there is nothing to save or restore.
      DispatchContext must not carry saved_segment. See SPEC-VM-015 §1.3 and §4.4.
    languages: [rust]
    severity: ERROR
    metadata:
      category: vm-scope-structural
      spec: SPEC-VM-015
      rejected-approach: save-restore
