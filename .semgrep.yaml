rules:
  # =============================================================================
  # DOEFF ARCHITECTURAL ENFORCEMENT RULES
  # =============================================================================
  # These rules enforce architectural decisions specific to the doeff framework.
  # For code quality patterns (immutability, naming), see doeff-linter (Rust).
  # 
  # Install semgrep: uv tool install semgrep
  # Run: semgrep --config .semgrep.yaml doeff/ packages/
  # =============================================================================

  # ---------------------------------------------------------------------------
  # EFFECT SYSTEM PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-direct-generator-in-do
    patterns:
      - pattern: |
          @do
          def $FUNC(...):
              ...
              yield from $EXPR
              ...
    paths:
      exclude:
        - "**/tests/**"
    message: |
      Do not use `yield from` in @do functions. Each effect should be yielded individually
      to maintain proper effect tracking and call tree construction.
      Use: `result = yield sub_program()` instead of `yield from sub_program()`.
    languages: [python]
    severity: ERROR
    metadata:
      category: effect-system
      rationale: "yield from bypasses effect tracking and breaks call tree construction"

  - id: doeff-no-async-in-do-function
    pattern-regex: '@do\s*\n\s*async\s+def\s+\w+'
    message: |
      @do functions should not be async. The @do decorator handles async execution
      through the effect system. Remove 'async' keyword and use Await effect for
      async operations: `result = yield Await(async_func())`.
    languages: [python]
    severity: ERROR
    metadata:
      category: effect-system
      rationale: "@do functions use generator-based concurrency, not async/await"

  - id: doeff-no-bare-return-in-generator
    patterns:
      - pattern: |
          @do
          def $FUNC(...):
              ...
              return
    message: |
      @do functions should return a value, not bare `return`. If no value is needed,
      use `return None` explicitly for clarity.
    languages: [python]
    severity: WARNING
    metadata:
      category: effect-system

  # ---------------------------------------------------------------------------
  # LAYER BOUNDARIES
  # ---------------------------------------------------------------------------

  - id: doeff-no-handler-import-in-effects
    patterns:
      - pattern-inside: |
          # In doeff/effects/ directory
          ...
      - pattern-either:
          - pattern: from doeff.handlers import $X
          - pattern: from doeff.handlers.$MOD import $X
          - pattern: import doeff.handlers
    paths:
      include:
        - "**/doeff/effects/"
    message: |
      Effects should not import from handlers. This violates layer separation.
      Effects define WHAT operations are available; handlers define HOW to execute them.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture
      rationale: "Effects layer must not depend on handlers layer"

  - id: doeff-no-runtime-import-in-effects
    patterns:
      - pattern-either:
          - pattern: from doeff.runtimes import $X
          - pattern: from doeff.interpreter import $X
          - pattern: import doeff.runtimes
    paths:
      include:
        - "**/doeff/effects/"
    message: |
      Effects should not import from runtimes or interpreter. This violates layer separation.
      Effects are pure data structures describing operations.
    languages: [python]
    severity: ERROR
    metadata:
      category: architecture

  # ---------------------------------------------------------------------------
  # PURITY PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-print-in-core
    patterns:
      - pattern: print(...)
    paths:
      include:
        - "**/doeff/"
      exclude:
        - "**/doeff/__main__.py"
        - "**/doeff/cli/"
        - "**/tests/**"
        - "**/examples/**"
    message: |
      Do not use print() in core library code. Use the Log effect for logging:
      `yield Log("message")` or configure loguru for internal debugging.
    languages: [python]
    severity: WARNING
    metadata:
      category: purity

  - id: doeff-no-datetime-now-in-do
    patterns:
      - pattern-inside: |
          @do
          def $FUNC(...):
              ...
      - pattern-either:
          - pattern: datetime.now(...)
          - pattern: datetime.datetime.now(...)
          - pattern: datetime.utcnow(...)
          - pattern: datetime.datetime.utcnow(...)
    message: |
      Do not call datetime.now() directly in @do functions. This makes the function
      impure and hard to test. Use the GetTime effect instead:
      `current_time = yield GetTime()`.
    languages: [python]
    severity: WARNING
    metadata:
      category: purity

  - id: doeff-no-random-in-do
    patterns:
      - pattern-inside: |
          @do
          def $FUNC(...):
              ...
      - pattern-either:
          - pattern: random.random(...)
          - pattern: random.randint(...)
          - pattern: random.choice(...)
          - pattern: random.shuffle(...)
    message: |
      Do not use random module directly in @do functions. This makes the function
      impure. Consider wrapping in an IO effect or injecting via Ask.
    languages: [python]
    severity: WARNING
    metadata:
      category: purity

  # ---------------------------------------------------------------------------
  # DEPENDENCY INJECTION PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-hardcoded-instantiation-in-do
    patterns:
      - pattern-inside: |
          @do
          def $FUNC(...):
              ...
      - pattern-either:
          - pattern: $CLIENT = httpx.Client(...)
          - pattern: $CLIENT = httpx.AsyncClient(...)
          - pattern: $CONN = sqlite3.connect(...)
          - pattern: $ENGINE = create_engine(...)
    message: |
      Do not instantiate clients/connections directly in @do functions. 
      Use dependency injection via the Ask effect:
      `client = yield Ask("http_client")`.
    languages: [python]
    severity: WARNING
    metadata:
      category: dependency-injection

  # ---------------------------------------------------------------------------
  # CESK ARCHITECTURE
  # ---------------------------------------------------------------------------

  - id: doeff-no-hardcoded-effect-handling-in-step
    patterns:
      - pattern-inside: |
          def step($...PARAMS):
              $...BODY
      - pattern-either:
          - pattern: |
              if isinstance($VAR, Ask):
                  $...THEN
          - pattern: |
              if isinstance($VAR, Get):
                  $...THEN
          - pattern: |
              if isinstance($VAR, Put):
                  $...THEN
    paths:
      include:
        - "**/doeff/cesk/step.py"
        - "**/doeff/step.py"
    message: |
      The step() function should not contain hardcoded effect handling logic.
      Effect-specific behavior must be implemented via extensible handlers.
      See SPEC-CESK-001: Separation of Concerns.
    languages: [python]
    severity: ERROR
    metadata:
      category: cesk-architecture

  # ---------------------------------------------------------------------------
  # CONCURRENCY API MIGRATION (SPEC-EFF-005 Redesign)
  # ---------------------------------------------------------------------------
  # These rules detect old concurrency patterns that need migration to the new
  # Future-based API. See specs/effects/SPEC-EFF-005-concurrency.md.

  - id: doeff-task-join-deprecated
    pattern: $TASK.join()
    message: |
      MIGRATION: task.join() is deprecated. Use Wait(task) instead.

      OLD: result = yield task.join()
      NEW: result = yield Wait(task)

      See SPEC-EFF-005 for details.
    languages: [python]
    severity: WARNING
    metadata:
      category: concurrency-migration
      spec: SPEC-EFF-005

  # ---------------------------------------------------------------------------
  # DEPRECATED EFFECT NAMES
  # ---------------------------------------------------------------------------

  - id: doeff-no-future-await-effect
    patterns:
      - pattern-either:
          - pattern: FutureAwaitEffect
          - pattern: from doeff.effects.future import FutureAwaitEffect
          - pattern: from doeff.effects import FutureAwaitEffect
    paths:
      exclude:
        # Allow in the definition file where the alias is defined
        - "**/doeff/effects/future.py"
        - "**/doeff/effects/__init__.py"
    message: |
      DEPRECATED: FutureAwaitEffect is renamed to PythonAsyncioAwaitEffect.

      This effect is specifically for Python asyncio awaitables, not a generic
      "future" abstraction. Use the new name for clarity:

      OLD: from doeff.effects import FutureAwaitEffect
      NEW: from doeff.effects import PythonAsyncioAwaitEffect

      Or just use the public API: yield Await(coroutine)
    languages: [python]
    severity: ERROR
    metadata:
      category: deprecated-names
      rationale: "FutureAwaitEffect is misleading - it's Python asyncio specific"

  # ---------------------------------------------------------------------------
  # PYTHON ASYNC SYNTAX ESCAPE - EXCLUSIVE PRODUCER ENFORCEMENT
  # ---------------------------------------------------------------------------
  # PythonAsyncSyntaxEscape may ONLY be produced by python_async_syntax_escape_handler.
  # This is an architectural constraint. See SPEC-CESK-004-handler-owned-blocking.md.

  - id: doeff-no-python-async-escape-in-handlers
    patterns:
      - pattern-either:
          - pattern: PythonAsyncSyntaxEscape(...)
          - pattern: python_async_escape(...)
          - pattern: from doeff.cesk.result import PythonAsyncSyntaxEscape
          - pattern: from doeff.cesk.result import python_async_escape
    paths:
      # ONLY enforce in handlers directory - that's where the constraint matters
      include:
        - "**/doeff/cesk/handlers/**"
      exclude:
        # SOLE AUTHORIZED PRODUCER
        - "**/doeff/cesk/handlers/python_async_syntax_escape_handler.py"
    message: |
      ARCHITECTURAL VIOLATION: PythonAsyncSyntaxEscape is EXCLUSIVELY for
      python_async_syntax_escape_handler. No other handler may produce this type.

      PythonAsyncSyntaxEscape exists ONLY because Python's `await` is SYNTAX,
      not a function call. It bridges doeff's sync CESK machine to Python's
      async runtime for users who explicitly choose async_run.

      If you think you need to produce PythonAsyncSyntaxEscape:
      1. You are wrong
      2. Rethink your approach
      3. If blocking is needed, do it directly in your handler's generator:
         result = blocking_call()  # next(gen) blocks until this returns

      See: specs/cesk-architecture/SPEC-CESK-004-handler-owned-blocking.md
    languages: [python]
    severity: ERROR
    metadata:
      category: cesk-architecture
      rationale: "PythonAsyncSyntaxEscape must only be produced by python_async_syntax_escape_handler"

  # ---------------------------------------------------------------------------
  # TESTING PATTERNS
  # ---------------------------------------------------------------------------

  - id: doeff-no-sleep-in-tests
    patterns:
      - pattern-either:
          - pattern: time.sleep(...)
          - pattern: await asyncio.sleep(...)
    paths:
      include:
        - tests/
    message: |
      Avoid time.sleep() or asyncio.sleep() in tests. Use SimulationRuntime
      with controlled time for deterministic testing.
    languages: [python]
    severity: WARNING
    metadata:
      category: testing

  # ---------------------------------------------------------------------------
  # IMPORT HYGIENE
  # ---------------------------------------------------------------------------

  - id: doeff-no-star-imports
    patterns:
      - pattern: from $MODULE import *
    paths:
      exclude:
        - "**/__init__.py"
    message: |
      Do not use star imports (from x import *). Import specific names
      for clarity and to avoid namespace pollution.
    languages: [python]
    severity: WARNING
    metadata:
      category: imports

  - id: doeff-no-typing-any-in-public-api
    patterns:
      - pattern-either:
          - pattern: |
              def $FUNC($...PARAMS) -> Any:
                  $...BODY
          - pattern: |
              async def $FUNC($...PARAMS) -> Any:
                  $...BODY
    paths:
      include:
        - "**/doeff/"
      exclude:
        - "**/tests/**"
        - "**/_*.py"
    message: |
      Avoid using `Any` in public API signatures. Use specific types or TypeVar
      for proper type safety. If truly dynamic, document why Any is necessary.
    languages: [python]
    severity: WARNING
    metadata:
      category: type-safety

  # ---------------------------------------------------------------------------
  # DOCUMENTATION - DEPRECATED API USAGE PATTERNS
  # ---------------------------------------------------------------------------
  # These rules detect USAGE of deprecated Runtime/Runner classes in docs.
  # The old class-based API was replaced with function-based sync_run/async_run.
  #
  # Excluded paths:
  # - docs/proposals/: Historical proposal documents
  # - docs/20-runtime-scheduler.md: Contains migration guide with "Before" examples

  - id: docs-no-runtime-instantiation
    pattern-regex: '(SyncRuntime|AsyncRuntime|AsyncioRuntime|SimulationRuntime)\s*\('
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: Runtime class instantiation detected.
      Use function-based API:
        sync_run(program, sync_handlers_preset)
        await async_run(program, async_handlers_preset)
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  - id: docs-no-runner-instantiation
    pattern-regex: '(SyncRunner|AsyncRunner)\s*\('
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: Runner class instantiation detected.
      Use function-based API:
        sync_run(program, sync_handlers_preset)
        await async_run(program, async_handlers_preset)
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  - id: docs-no-runtime-run-method
    pattern-regex: 'runtime\.run\s*\('
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: runtime.run() method call detected.
      Use function-based API:
        sync_run(program, sync_handlers_preset)
        await async_run(program, async_handlers_preset)
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  - id: docs-no-runtime-import
    pattern-regex: 'from doeff\.(cesk\.runtime|cesk\.runner|runtimes) import'
    paths:
      include:
        - "/docs/**/*.md"
      exclude:
        - "/docs/proposals/**"
        - "/docs/20-runtime-scheduler.md"
    message: |
      DEPRECATED: Import from removed runtime/runner modules.
      Use: from doeff import sync_run, async_run, sync_handlers_preset, async_handlers_preset
    languages: [generic]
    severity: ERROR
    metadata:
      category: docs-deprecation

  # ---------------------------------------------------------------------------
  # DOEFF DOEXPR HIERARCHY ENFORCEMENT
  # ---------------------------------------------------------------------------

  - id: doeff-doexpr-root-boundary-python
    patterns:
      - pattern-inside: |
          def _coerce_program($PROGRAM):
              ...
      - pattern-either:
          - pattern: isinstance($PROGRAM, ($VM.EffectBase, $VM.DoCtrlBase))
          - pattern: isinstance($PROGRAM, ($VM.DoCtrlBase, $VM.EffectBase))
    paths:
      include:
        - "**/doeff/rust_vm.py"
    message: |
      Boundary validation must use unified DoExpr root.
      Use: isinstance(program, vm.DoExpr)
    languages: [python]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "run()/async_run() boundary must validate against single DoExpr root"

  - id: doeff-withhandler-no-program-keyword
    pattern: WithHandler(..., program=$EXPR, ...)
    paths:
      include:
        - "**/doeff/**/*.py"
        - "**/packages/doeff-vm/doeff_vm/**/*.py"
        - "**/tests/public_api/**/*.py"
    message: |
      WithHandler must use `expr=` keyword (or positional expr), not `program=`.
      Use: WithHandler(handler=..., expr=...)
    languages: [python]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "canonical WithHandler signature is (handler, expr: DoExpr)"

  - id: doeff-doexpr-root-check-to-generator-strict
    patterns:
      - pattern-inside: |
          fn to_generator_strict($...ARGS) -> $RET {
              ...
          }
      - pattern-either:
          - pattern: $OBJ.is_instance_of::<PyEffectBase>()
          - pattern: $OBJ.is_instance_of::<PyDoCtrlBase>()
          - pattern: $OBJ.is_instance_of::<PyKPC>()
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      to_generator_strict must classify using unified PyDoExprBase root check.
      Use: obj.is_instance_of::<PyDoExprBase>()
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "single-root DoExpr boundary avoids split classification logic"

  - id: doeff-doexpr-root-check-withhandler-constructor
    patterns:
      - pattern-inside: |
          impl PyWithHandler {
              ...
          }
      - pattern-either:
          - pattern: $OBJ.is_instance_of::<PyEffectBase>()
          - pattern: $OBJ.is_instance_of::<PyDoCtrlBase>()
          - pattern: $OBJ.is_instance_of::<PyKPC>()
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      WithHandler constructor must validate expr via PyDoExprBase root.
      Use: expr_obj.is_instance_of::<PyDoExprBase>()
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-hierarchy
      rationale: "WithHandler expr is DoExpr, not a disjunction of concrete bases"

  - id: doeff-no-yielded-effect-variant
    patterns:
      - pattern: Yielded::Effect($X)
    paths:
      include:
        - "**/packages/doeff-vm/src/**/*.rs"
    message: |
      Perform architecture: direct Yielded::Effect is forbidden.
      Effects must be lifted into DoCtrl::Perform(effect) and handled via DoCtrl path.
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-perform
      rationale: "Dispatch entry must be explicit via DoCtrl::Perform"

  - id: doeff-classify-effect-must-lift-to-perform
    patterns:
      - pattern-inside: |
          fn classify_yielded($...ARGS) -> $RET {
              ...
          }
      - pattern: return Ok(Yielded::Effect($E));
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      classify_yielded must lift effect values to DoCtrl::Perform(effect),
      not return Yielded::Effect.
    languages: [rust]
    severity: ERROR
    metadata:
      category: doexpr-perform
      rationale: "Effect data and dispatch control must be explicitly separated"

  # ---------------------------------------------------------------------------
  # SPEC AUDIT SA-001: GAP ENFORCEMENT RULES
  # ---------------------------------------------------------------------------

  - id: spec-gap-SA-001-G06-marker-attr-effects
    patterns:
      - pattern-either:
          - pattern: has_true_attr($OBJ, "__doeff_state_get__")
          - pattern: has_true_attr($OBJ, "__doeff_state_put__")
          - pattern: has_true_attr($OBJ, "__doeff_state_modify__")
          - pattern: has_true_attr($OBJ, "__doeff_reader_ask__")
          - pattern: has_true_attr($OBJ, "__doeff_writer_tell__")
    message: |
      SA-001-G06: Effect detection via marker attributes.
      Should use isinstance with Rust #[pyclass] types per SPEC-008 R11-A.
    languages: [rust]
    severity: WARNING
    metadata:
      category: spec-audit-SA-001
      gap: G06

  - id: spec-gap-SA-001-G08-classify-duck-typing
    patterns:
      - pattern-either:
          - pattern: $OBJ.getattr(...)
          - pattern: $OBJ.hasattr(...)
    paths:
      include:
        - "**/packages/doeff-vm/src/pyvm.rs"
    message: |
      SA-001-G08: classify_yielded uses duck-typing.
      Should use is_instance_of checks only per SPEC-008 R11-C.
    languages: [rust]
    severity: WARNING
    metadata:
      category: spec-audit-SA-001
      gap: G08

  # ---------------------------------------------------------------------------
  # PUBLIC API LOCATION GUARDS
  # ---------------------------------------------------------------------------

  - id: doeff-public-api-no-subpackage-imports
    patterns:
      - pattern-either:
          - pattern-regex: '^from\\s+doeff\\.[A-Za-z0-9_.]+\\s+import\\s+'
          - pattern-regex: '^import\\s+doeff\\.[A-Za-z0-9_.]+'
    paths:
      include:
        - "**/tests/public_api/**/*.py"
        - "**/examples/**/*.py"
      exclude:
        - "**/examples/cesk/**"
        - "**/examples/custom_handlers.py"
    message: |
      Public-facing migration policy: import from top-level `doeff` only.
      Replace `from doeff.<subpackage> import ...` with `from doeff import ...`.
      CESK examples are excluded (planned deletion).
    languages: [python]
    severity: ERROR
    metadata:
      category: public-api-location
      rationale: "Public API location is fixed at top-level doeff"

  - id: doeff-public-docs-no-subpackage-imports
    patterns:
      - pattern-regex: 'from\\s+doeff\\.[A-Za-z0-9_.]+\\s+import\\s+'
    paths:
      include:
        - "**/docs/06-io-effects.md"
        - "**/docs/16-run-program-api.md"
    message: |
      Consumer-facing docs must use top-level imports: `from doeff import ...`.
    languages: [generic]
    severity: ERROR
    metadata:
      category: public-api-location
      rationale: "Docs should reflect stable top-level public API"
